From 65b68a814742181e9a709949b8e3f06fb08e749b Mon Sep 17 00:00:00 2001
From: Srinath <srinath@mistralsolutions.com>
Date: Thu, 5 Aug 2010 12:03:25 +0530
Subject: [PATCH] Added Crane Board support

---
 arch/arm/configs/am3517_crane_defconfig      | 1768 ++++++++++++++++++++++++++
 arch/arm/mach-omap2/Kconfig                  |    6 +
 arch/arm/mach-omap2/Makefile                 |    2 +
 arch/arm/mach-omap2/board-am3517crane.c      |  773 +++++++++++
 arch/arm/mach-omap2/mmc-am3517crane.c        |  267 ++++
 arch/arm/mach-omap2/mmc-am3517crane.h        |   22 +
 arch/arm/mach-omap2/tps65910-pmic.c          |  195 +++
 arch/arm/tools/mach-types                    |    1 +
 drivers/gpio/Makefile                        |    1 +
 drivers/i2c/busses/i2c-omap.c                |    3 +-
 drivers/mfd/Kconfig                          |   13 +
 drivers/mfd/Makefile                         |    4 +-
 drivers/mfd/tps65910-core.c                  |  741 +++++++++++
 drivers/rtc/Kconfig                          |    8 +
 drivers/rtc/Makefile                         |    1 +
 drivers/rtc/rtc-tps65910.c                   |  657 ++++++++++
 drivers/usb/host/ehci-hub.c                  |    9 +-
 drivers/usb/musb/Kconfig                     |    6 +-
 drivers/usb/musb/Makefile                    |    3 +-
 drivers/usb/musb/musb_core.c                 |    2 +-
 drivers/usb/musb/musb_core.h                 |    2 +-
 drivers/usb/musb/musb_gadget.c               |    2 +-
 drivers/usb/musb/musb_gadget_ep0.c           |    2 +-
 drivers/usb/musb/musb_io.h                   |    5 +-
 drivers/usb/musb/musb_virthub.c              |    8 +-
 drivers/video/omap2/displays/panel-generic.c |    9 +
 drivers/video/omap2/dss/venc.c               |   15 +-
 include/linux/i2c/tps65910.h                 |  278 ++++
 28 files changed, 4779 insertions(+), 24 deletions(-)
 create mode 100644 arch/arm/configs/am3517_crane_defconfig
 create mode 100644 arch/arm/mach-omap2/board-am3517crane.c
 create mode 100644 arch/arm/mach-omap2/mmc-am3517crane.c
 create mode 100644 arch/arm/mach-omap2/mmc-am3517crane.h
 create mode 100644 arch/arm/mach-omap2/tps65910-pmic.c
 create mode 100644 drivers/mfd/tps65910-core.c
 create mode 100644 drivers/rtc/rtc-tps65910.c
 create mode 100644 include/linux/i2c/tps65910.h

diff --git a/arch/arm/configs/am3517_crane_defconfig b/arch/arm/configs/am3517_crane_defconfig
new file mode 100644
index 0000000..24ffc83
--- /dev/null
+++ b/arch/arm/configs/am3517_crane_defconfig
@@ -0,0 +1,1768 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.32
+# Fri Nov 26 17:48:55 2010
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_TREE_PREEMPT_RCU is not set
+# CONFIG_TINY_RCU is not set
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_GROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_RT_GROUP_SCHED is not set
+CONFIG_USER_SCHED=y
+# CONFIG_CGROUP_SCHED is not set
+# CONFIG_CGROUPS is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_CLK=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+CONFIG_INLINE_SPIN_UNLOCK=y
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+CONFIG_INLINE_READ_UNLOCK=y
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+CONFIG_INLINE_WRITE_UNLOCK=y
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_STMP3XXX is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_DAVINCI is not set
+CONFIG_ARCH_OMAP=y
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_U8500 is not set
+
+#
+# TI OMAP Implementations
+#
+CONFIG_ARCH_OMAP_OTG=y
+# CONFIG_ARCH_OMAP1 is not set
+# CONFIG_ARCH_OMAP2 is not set
+CONFIG_ARCH_OMAP3=y
+# CONFIG_ARCH_OMAP4 is not set
+
+#
+# OMAP Feature Selections
+#
+CONFIG_OMAP_RESET_CLOCKS=y
+CONFIG_OMAP_MUX=y
+# CONFIG_OMAP_MUX_DEBUG is not set
+CONFIG_OMAP_MUX_WARNINGS=y
+CONFIG_OMAP_MCBSP=y
+# CONFIG_OMAP_MBOX_FWK is not set
+# CONFIG_OMAP_MPU_TIMER is not set
+CONFIG_OMAP_32K_TIMER=y
+# CONFIG_OMAP3_L2_AUX_SECURE_SAVE_RESTORE is not set
+CONFIG_OMAP_32K_TIMER_HZ=128
+CONFIG_OMAP_DM_TIMER=y
+# CONFIG_OMAP_LL_DEBUG_UART1 is not set
+# CONFIG_OMAP_LL_DEBUG_UART2 is not set
+CONFIG_OMAP_LL_DEBUG_UART3=y
+# CONFIG_OMAP_LL_DEBUG_NONE is not set
+# CONFIG_OMAP_PM_NONE is not set
+CONFIG_OMAP_PM_NOOP=y
+# CONFIG_OMAP_PM_SRF is not set
+CONFIG_ARCH_OMAP34XX=y
+CONFIG_ARCH_OMAP3430=y
+CONFIG_OMAP_PACKAGE_CBB=y
+
+#
+# OMAP Board Type
+#
+# CONFIG_MACH_OMAP3_BEAGLE is not set
+# CONFIG_MACH_OMAP_LDP is not set
+# CONFIG_MACH_OVERO is not set
+# CONFIG_MACH_OMAP3EVM is not set
+# CONFIG_MACH_OMAP3517EVM is not set
+CONFIG_MACH_CRANEBOARD=y
+# CONFIG_MACH_OMAP3_PANDORA is not set
+# CONFIG_MACH_OMAP3_TOUCHBOOK is not set
+# CONFIG_MACH_OMAP_3430SDP is not set
+# CONFIG_MACH_NOKIA_RX51 is not set
+# CONFIG_MACH_OMAP_ZOOM2 is not set
+# CONFIG_MACH_OMAP_ZOOM3 is not set
+# CONFIG_MACH_CM_T35 is not set
+# CONFIG_MACH_IGEP0020 is not set
+# CONFIG_MACH_OMAP_3630SDP is not set
+# CONFIG_OMAP3_EMU is not set
+# CONFIG_OMAP3_SDRC_AC_TIMING is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_HAS_TLS_REG=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+CONFIG_ARM_ERRATA_430973=y
+CONFIG_ARM_ERRATA_458693=y
+CONFIG_ARM_ERRATA_460075=y
+CONFIG_COMMON_CLKDEV=y
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_HZ=128
+# CONFIG_THUMB2_KERNEL is not set
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_HAS_HOLES_MEMORYMODEL=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="root=/dev/nfs nfsroot=192.168.0.1:/home/user/buildroot ip=192.168.0.2:192.168.0.1:192.168.0.1:255.255.255.0:tgt:eth0:off rw console=ttyS2,115200n8"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_FREQ is not set
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_MISC=y
+
+#
+# Power management options
+#
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+# CONFIG_PM_VERBOSE is not set
+CONFIG_CAN_PM_TRACE=y
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+# CONFIG_PM_TEST_SUSPEND is not set
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_APM_EMULATION is not set
+# CONFIG_PM_RUNTIME is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+CONFIG_CAN=y
+CONFIG_CAN_RAW=y
+CONFIG_CAN_BCM=y
+
+#
+# CAN Device Drivers
+#
+CONFIG_CAN_VCAN=y
+CONFIG_CAN_DEV=y
+CONFIG_CAN_CALC_BITTIMING=y
+CONFIG_CAN_TI_HECC=y
+# CONFIG_CAN_SJA1000 is not set
+
+#
+# CAN USB interfaces
+#
+# CONFIG_CAN_EMS_USB is not set
+CONFIG_CAN_DEBUG_DEVICES=y
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+# CONFIG_LIB80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_TESTS is not set
+CONFIG_MTD_CONCAT=y
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_OMAP2=y
+# CONFIG_MTD_NAND_OMAP_PREFETCH is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=32768
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+CONFIG_TI_DAVINCI_EMAC=y
+# CONFIG_DM9000 is not set
+# CONFIG_ETHOC is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851_MLL is not set
+CONFIG_NETDEV_1000=y
+CONFIG_NETDEV_10000=y
+CONFIG_WLAN=y
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_HOSTAP is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+CONFIG_USB_USBNET=y
+# CONFIG_USB_NET_AX8817X is not set
+CONFIG_USB_NET_CDCETHER=y
+# CONFIG_USB_NET_CDC_EEM is not set
+CONFIG_USB_NET_DM9601=y
+# CONFIG_USB_NET_SMSC95XX is not set
+# CONFIG_USB_NET_GL620A is not set
+# CONFIG_USB_NET_NET1080 is not set
+# CONFIG_USB_NET_PLUSB is not set
+# CONFIG_USB_NET_MCS7830 is not set
+# CONFIG_USB_NET_RNDIS_HOST is not set
+# CONFIG_USB_NET_CDC_SUBSET is not set
+# CONFIG_USB_NET_ZAURUS is not set
+# CONFIG_USB_NET_INT51X1 is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=32
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+CONFIG_SERIAL_8250_DETECT_IRQ=y
+CONFIG_SERIAL_8250_RSA=y
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+# CONFIG_I2C_CHARDEV is not set
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+CONFIG_I2C_OMAP=y
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_SPI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_TPS65910 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+
+#
+# AC97 GPIO expanders:
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_OMAP_WATCHDOG=y
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TWL4030_CORE is not set
+CONFIG_TPS65910_CORE=y
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_AB3100_CORE is not set
+# CONFIG_MFD_88PM8607 is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_BQ24022 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_TPS65910 is not set
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+CONFIG_VIDEO_ALLOW_V4L1=y
+CONFIG_VIDEO_V4L1_COMPAT=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_MEDIA_TUNER_TEA5761=y
+CONFIG_MEDIA_TUNER_TEA5767=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_MEDIA_TUNER_MC44S803=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_V4L1=y
+# CONFIG_VIDEO_CAPTURE_DRIVERS is not set
+# CONFIG_RADIO_ADAPTERS is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_OMAP_BOOTLOADER_INIT is not set
+CONFIG_OMAP2_VRAM=y
+CONFIG_OMAP2_VRFB=y
+CONFIG_OMAP2_DSS=y
+CONFIG_OMAP2_VRAM_SIZE=4
+# CONFIG_OMAP2_DSS_DEBUG_SUPPORT is not set
+# CONFIG_OMAP2_DSS_RFBI is not set
+CONFIG_OMAP2_DSS_VENC=y
+# CONFIG_OMAP2_VENC_OUT_TYPE_SVIDEO is not set
+CONFIG_OMAP2_VENC_OUT_TYPE_COMPOSITE=y
+# CONFIG_OMAP2_DSS_SDI is not set
+# CONFIG_OMAP2_DSS_DSI is not set
+# CONFIG_OMAP2_DSS_FAKE_VSYNC is not set
+CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK=1
+CONFIG_FB_OMAP2=y
+# CONFIG_FB_OMAP2_DEBUG_SUPPORT is not set
+# CONFIG_FB_OMAP2_FORCE_AUTO_UPDATE is not set
+CONFIG_FB_OMAP2_NUM_FBS=1
+
+#
+# OMAP2/3 Display Device Drivers
+#
+CONFIG_PANEL_GENERIC=y
+# CONFIG_PANEL_SHARP_LS037V7DW01 is not set
+# CONFIG_PANEL_SHARP_LQ043T1DG01 is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+CONFIG_USB_OTG=y
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+CONFIG_USB_MUSB_HDRC=y
+CONFIG_USB_MUSB_SOC=y
+
+#
+# OMAP 343x high speed USB support
+#
+# CONFIG_USB_MUSB_HOST is not set
+# CONFIG_USB_MUSB_PERIPHERAL is not set
+CONFIG_USB_MUSB_OTG=y
+CONFIG_USB_GADGET_MUSB_HDRC=y
+CONFIG_USB_MUSB_HDRC_HCD=y
+# CONFIG_MUSB_PIO_ONLY is not set
+# CONFIG_USB_TI_CPPI_DMA is not set
+CONFIG_USB_TI_CPPI41_DMA=y
+CONFIG_USB_MUSB_DEBUG=y
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+CONFIG_USB_TEST=y
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_R8A66597 is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C_HSOTG is not set
+# CONFIG_USB_GADGET_IMX is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LANGWELL is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+CONFIG_USB_MASS_STORAGE=m
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_MULTI is not set
+
+#
+# OTG and related infrastructure
+#
+CONFIG_USB_OTG_UTILS=y
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_ISP1301_OMAP is not set
+# CONFIG_USB_ULPI is not set
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_OMAP is not set
+CONFIG_MMC_OMAP_HS=y
+# CONFIG_MMC_AT91 is not set
+# CONFIG_MMC_ATMELMCI is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+CONFIG_RTC_DRV_TPS65910=y
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+
+#
+# TI VLYNQ
+#
+# CONFIG_STAGING is not set
+
+#
+# CBUS support
+#
+# CONFIG_CBUS is not set
+
+#
+# File systems
+#
+CONFIG_FS_JOURNAL_INFO=y
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT4_FS is not set
+CONFIG_JBD=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_QUOTA=y
+# CONFIG_QUOTA_NETLINK_INTERFACE is not set
+CONFIG_PRINT_QUOTA_WARNING=y
+CONFIG_QUOTA_TREE=y
+# CONFIG_QFMT_V1 is not set
+CONFIG_QFMT_V2=y
+CONFIG_QUOTACTL=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_JFFS2_CMODE_NONE is not set
+CONFIG_JFFS2_CMODE_PRIORITY=y
+# CONFIG_JFFS2_CMODE_SIZE is not set
+# CONFIG_JFFS2_CMODE_FAVOURLZO is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+CONFIG_NFS_V4=y
+# CONFIG_NFS_V4_1 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+CONFIG_DEBUG_MUTEXES=y
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+# CONFIG_PAGE_POISONING is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_ENABLE_DEFAULT_TRACERS is not set
+# CONFIG_BOOT_TRACER is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_KMEMTRACE is not set
+# CONFIG_WORKQUEUE_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_ERRORS is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_EARLY_PRINTK is not set
+# CONFIG_DEBUG_ICEDCC is not set
+# CONFIG_OC_ETM is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_DEFAULT_SECURITY_SELINUX is not set
+# CONFIG_DEFAULT_SECURITY_SMACK is not set
+# CONFIG_DEFAULT_SECURITY_TOMOYO is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=m
+# CONFIG_CRYPTO_LRW is not set
+CONFIG_CRYPTO_PCBC=m
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=y
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
diff --git a/arch/arm/mach-omap2/Kconfig b/arch/arm/mach-omap2/Kconfig
index b72ae06..d965d58 100644
--- a/arch/arm/mach-omap2/Kconfig
+++ b/arch/arm/mach-omap2/Kconfig
@@ -96,6 +96,11 @@ config MACH_OMAP3517EVM
 	depends on ARCH_OMAP3 && ARCH_OMAP34XX
 	select OMAP_PACKAGE_CBB

+config MACH_CRANEBOARD
+	bool "AM3517/05 Crane board"
+	depends on ARCH_OMAP3 && ARCH_OMAP34XX
+	select OMAP_PACKAGE_CBB
+
 config PMIC_TPS65023
 	bool "TPS65023 Power Module"
 	default y
@@ -171,6 +176,7 @@ config MACH_OMAP_4430SDP
 	bool "OMAP 4430 SDP board"
 	depends on ARCH_OMAP4

+
 config OMAP3_EMU
 	bool "OMAP3 debugging peripherals"
 	depends on ARCH_OMAP3
diff --git a/arch/arm/mach-omap2/Makefile b/arch/arm/mach-omap2/Makefile
index fa01859..9042317 100644
--- a/arch/arm/mach-omap2/Makefile
+++ b/arch/arm/mach-omap2/Makefile
@@ -130,6 +130,8 @@ obj-$(CONFIG_MACH_OMAP_4430SDP)		+= board-4430sdp.o
 obj-$(CONFIG_MACH_OMAP3517EVM)     	+= board-am3517evm.o \
 					   mmc-am3517evm.o

+obj-$(CONFIG_MACH_CRANEBOARD) 		+= board-am3517crane.o \
+					   mmc-am3517crane.o
 # Platform specific device init code
 obj-y					+= usb-musb.o
 obj-$(CONFIG_MACH_OMAP2_TUSB6010)	+= usb-tusb6010.o
diff --git a/arch/arm/mach-omap2/board-am3517crane.c b/arch/arm/mach-omap2/board-am3517crane.c
new file mode 100644
index 0000000..0bf4f60
--- /dev/null
+++ b/arch/arm/mach-omap2/board-am3517crane.c
@@ -0,0 +1,773 @@
+/*
+ * linux/arch/arm/mach-omap2/board-am3517crane.c
+ *
+ * Copyright (C) 2010 Mistral Solutions Pvt LtD <www.mistralsolutions.com>
+ * Author: Srinath.R <srinath@mistralsolutions.com>
+ *
+ * Based on mach-omap2/board-am3517evm.c
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as  published by the
+ * Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any kind,
+ * whether express or implied; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/i2c/tsc2004.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/nand.h>
+#include <linux/input.h>
+#include <linux/tca6416_keypad.h>
+#include <linux/davinci_emac.h>
+#include <linux/i2c/pca953x.h>
+#include <linux/regulator/machine.h>
+#include <linux/can/platform/ti_hecc.h>
+#include <linux/i2c/tps65910.h>
+
+#include <mach/hardware.h>
+#include <mach/am35xx.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+
+#include <plat/board.h>
+#include <plat/common.h>
+#include <plat/control.h>
+#include <plat/usb.h>
+#include <plat/display.h>
+#include <plat/gpmc.h>
+#include <plat/nand.h>
+
+#include "mmc-am3517crane.h"
+#include "mux.h"
+
+#define GPMC_CS0_BASE  0x60
+#define GPMC_CS_SIZE   0x30
+
+#define NAND_BLOCK_SIZE        SZ_128K
+
+static struct mtd_partition am3517crane_nand_partitions[] = {
+	/* All the partition sizes are listed in terms of NAND block size */
+	{
+		.name           = "xloader-nand",
+		.offset         = 0,
+		.size           = 4*(SZ_128K),
+		.mask_flags     = MTD_WRITEABLE
+	},
+	{
+		.name           = "uboot-nand",
+		.offset         = MTDPART_OFS_APPEND,
+		.size           = 28*(SZ_128K),
+		.mask_flags     = MTD_WRITEABLE
+	},
+	{
+		.name           = "params-nand",
+		.offset         = MTDPART_OFS_APPEND,
+		.size           = 4*(SZ_128K)
+	},
+	{
+		.name           = "linux-nand",
+		.offset         = MTDPART_OFS_APPEND,
+		.size           = 80*(SZ_128K)
+	},
+	{
+		.name           = "jffs2-nand",
+		.size           = MTDPART_SIZ_FULL,
+		.offset         = MTDPART_OFS_APPEND,
+	},
+};
+
+static struct omap_nand_platform_data am3517crane_nand_data = {
+	.parts          = am3517crane_nand_partitions,
+	.nr_parts       = ARRAY_SIZE(am3517crane_nand_partitions),
+	.nand_setup     = NULL,
+	.dma_channel    = -1,           /* disable DMA in OMAP NAND driver */
+	.dev_ready      = NULL,
+};
+
+static struct resource am3517crane_nand_resource = {
+	.flags          = IORESOURCE_MEM,
+};
+
+static struct platform_device am3517crane_nand_device = {
+	.name           = "omap2-nand",
+	.id             = 0,
+	.dev            = {
+		.platform_data  = &am3517crane_nand_data,
+	},
+	.num_resources  = 1,
+	.resource       = &am3517crane_nand_resource,
+};
+
+void __init am3517crane_flash_init(void)
+{
+	u8 cs = 0;
+	u8 nandcs = GPMC_CS_NUM + 1;
+	u32 gpmc_base_add = OMAP34XX_GPMC_VIRT;
+
+	while (cs < GPMC_CS_NUM) {
+		u32 ret = 0;
+		ret = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG1);
+
+		if ((ret & 0xC00) == 0x800) {
+			/* Found it!! */
+			if (nandcs > GPMC_CS_NUM)
+				nandcs = cs;
+		}
+		cs++;
+	}
+	if (nandcs > GPMC_CS_NUM) {
+		printk(KERN_INFO "NAND: Unable to find configuration "
+				" in GPMC\n ");
+		return;
+	}
+
+	if (nandcs < GPMC_CS_NUM) {
+		am3517crane_nand_data.cs   = nandcs;
+		am3517crane_nand_data.gpmc_cs_baseaddr =
+		(void *)(gpmc_base_add + GPMC_CS0_BASE + nandcs*GPMC_CS_SIZE);
+
+		am3517crane_nand_data.gpmc_baseaddr = (void *)(gpmc_base_add);
+
+		if (platform_device_register(&am3517crane_nand_device) < 0)
+			printk(KERN_ERR "Unable to register NAND device\n");
+
+	}
+}
+
+
+#define AM35XX_EVM_PHY_MASK		(0xF)
+#define AM35XX_EVM_MDIO_FREQUENCY    	(1000000)
+
+static struct emac_platform_data am3517_crane_emac_pdata = {
+	.phy_mask       = AM35XX_EVM_PHY_MASK,
+	.mdio_max_freq  = AM35XX_EVM_MDIO_FREQUENCY,
+	.rmii_en        = 1,
+};
+
+static int __init eth_addr_setup(char *str)
+{
+	int i;
+
+	if (str == NULL)
+		return 0;
+	for (i = 0; i < ETH_ALEN; i++)
+		am3517_crane_emac_pdata.mac_addr[i] = simple_strtol(&str[i*3],
+							(char **)NULL, 16);
+	return 1;
+}
+
+/* Get MAC address from kernel boot parameter eth=AA:BB:CC:DD:EE:FF */
+__setup("eth=", eth_addr_setup);
+
+static struct resource am3517_emac_resources[] = {
+	{
+		.start  = AM35XX_IPSS_EMAC_BASE,
+		.end    = AM35XX_IPSS_EMAC_BASE + 0x3FFFF,
+		.flags  = IORESOURCE_MEM,
+	},
+	{
+		.start  = INT_35XX_EMAC_C0_RXTHRESH_IRQ,
+		.end    = INT_35XX_EMAC_C0_RXTHRESH_IRQ,
+		.flags  = IORESOURCE_IRQ,
+	},
+	{
+		.start  = INT_35XX_EMAC_C0_RX_PULSE_IRQ,
+		.end    = INT_35XX_EMAC_C0_RX_PULSE_IRQ,
+		.flags  = IORESOURCE_IRQ,
+	},
+	{
+		.start  = INT_35XX_EMAC_C0_TX_PULSE_IRQ,
+		.end    = INT_35XX_EMAC_C0_TX_PULSE_IRQ,
+		.flags  = IORESOURCE_IRQ,
+	},
+	{
+		.start  = INT_35XX_EMAC_C0_MISC_PULSE_IRQ,
+		.end    = INT_35XX_EMAC_C0_MISC_PULSE_IRQ,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device am3517_emac_device = {
+	.name           = "davinci_emac",
+	.id             = -1,
+	.num_resources  = ARRAY_SIZE(am3517_emac_resources),
+	.resource       = am3517_emac_resources,
+};
+
+static void am3517_enable_ethernet_int(void)
+{
+	u32 regval;
+
+	regval = omap_ctrl_readl(AM35XX_CONTROL_LVL_INTR_CLEAR);
+	regval = (regval | AM35XX_CPGMAC_C0_RX_PULSE_CLR |
+		AM35XX_CPGMAC_C0_TX_PULSE_CLR |
+		AM35XX_CPGMAC_C0_MISC_PULSE_CLR |
+		AM35XX_CPGMAC_C0_RX_THRESH_CLR);
+
+	omap_ctrl_writel(regval, AM35XX_CONTROL_LVL_INTR_CLEAR);
+	regval = omap_ctrl_readl(AM35XX_CONTROL_LVL_INTR_CLEAR);
+}
+
+static void am3517_disable_ethernet_int(void)
+{
+	u32 regval;
+
+	regval = omap_ctrl_readl(AM35XX_CONTROL_LVL_INTR_CLEAR);
+	regval = (regval | AM35XX_CPGMAC_C0_RX_PULSE_CLR |
+			AM35XX_CPGMAC_C0_TX_PULSE_CLR);
+	omap_ctrl_writel(regval, AM35XX_CONTROL_LVL_INTR_CLEAR);
+	regval = omap_ctrl_readl(AM35XX_CONTROL_LVL_INTR_CLEAR);
+}
+
+void am3517_crane_ethernet_init(struct emac_platform_data *pdata)
+{
+	unsigned int regval;
+
+	pdata->ctrl_reg_offset          = AM35XX_EMAC_CNTRL_OFFSET;
+	pdata->ctrl_mod_reg_offset      = AM35XX_EMAC_CNTRL_MOD_OFFSET;
+	pdata->ctrl_ram_offset          = AM35XX_EMAC_CNTRL_RAM_OFFSET;
+	pdata->mdio_reg_offset          = AM35XX_EMAC_MDIO_OFFSET;
+	pdata->ctrl_ram_size            = AM35XX_EMAC_CNTRL_RAM_SIZE;
+	pdata->version                  = EMAC_VERSION_2;
+	pdata->hw_ram_addr              = AM35XX_EMAC_HW_RAM_ADDR;
+	pdata->interrupt_enable 	= am3517_enable_ethernet_int;
+	pdata->interrupt_disable 	= am3517_disable_ethernet_int;
+	am3517_emac_device.dev.platform_data     = pdata;
+	platform_device_register(&am3517_emac_device);
+
+	regval = omap_ctrl_readl(AM35XX_CONTROL_IP_SW_RESET);
+	regval = regval & (~(AM35XX_CPGMACSS_SW_RST));
+	omap_ctrl_writel(regval, AM35XX_CONTROL_IP_SW_RESET);
+	regval = omap_ctrl_readl(AM35XX_CONTROL_IP_SW_RESET);
+
+	return ;
+}
+
+static void __init am3517_crane_display_init(void)
+{
+	omap_mux_init_gpio(52, OMAP_PIN_OUTPUT);
+	gpio_request(52, "dvi_enable");
+	gpio_direction_output(52, 1);
+}
+
+
+
+static struct omap_dss_device am3517_crane_tv_device = {
+	.type 			= OMAP_DISPLAY_TYPE_VENC,
+	.name 			= "tv",
+	.driver_name		= "venc",
+	.phy.venc.type          = OMAP_DSS_VENC_TYPE_COMPOSITE,
+	.platform_enable	= NULL,
+	.platform_disable	= NULL,
+};
+
+static int am3517_crane_panel_enable_dvi(struct omap_dss_device *dssdev)
+{
+	gpio_set_value(52, 1);
+	return 0;
+}
+
+static void am3517_crane_panel_disable_dvi(struct omap_dss_device *dssdev)
+{
+	gpio_set_value(52, 0);
+}
+
+static struct omap_dss_device am3517_crane_dvi_device = {
+	.type			= OMAP_DISPLAY_TYPE_DPI,
+	.name			= "dvi",
+	.driver_name		= "generic_panel",
+	.phy.dpi.data_lines	= 24,
+	.platform_enable	= am3517_crane_panel_enable_dvi,
+	.platform_disable	= am3517_crane_panel_disable_dvi,
+};
+
+static struct omap_dss_device *am3517_crane_dss_devices[] = {
+	&am3517_crane_tv_device,
+	&am3517_crane_dvi_device,
+};
+
+static struct omap_dss_board_info am3517_crane_dss_data = {
+	.num_devices	= ARRAY_SIZE(am3517_crane_dss_devices),
+	.devices	= am3517_crane_dss_devices,
+	.default_device	= &am3517_crane_dvi_device,
+};
+
+struct platform_device am3517_crane_dss_device = {
+	.name		= "omapdss",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= &am3517_crane_dss_data,
+	},
+};
+
+static u64 vpfe_capture_dma_mask = DMA_BIT_MASK(32);
+static struct resource dm644x_ccdc_resource[] = {
+	/* CCDC Base address */
+	{
+		.start	= AM35XX_IPSS_VPFE_BASE,
+		.end	= AM35XX_IPSS_VPFE_BASE + 0xffff,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device dm644x_ccdc_dev = {
+	.name		= "dm644x_ccdc",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(dm644x_ccdc_resource),
+	.resource	= dm644x_ccdc_resource,
+	.dev = {
+		.dma_mask		= &vpfe_capture_dma_mask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+	},
+};
+
+static struct regulator_consumer_supply am3517_crane_vdd1_supplies[] = {
+	{
+		.supply = "vdd_core",
+	},
+};
+
+static struct regulator_init_data am3517_crane_regulator_vdd1 = {
+	.constraints = {
+		.min_uV = 1200000,
+		.max_uV = 1200000,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+		.always_on = true,
+		.apply_uV = true,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(am3517_crane_vdd1_supplies),
+	.consumer_supplies = am3517_crane_vdd1_supplies,
+};
+
+static struct regulator_consumer_supply am3517_crane_vdd2_supplies[] = {
+	{
+		.supply = "vddshv",
+	},
+};
+
+static struct regulator_init_data am3517_crane_regulator_vdd2 = {
+	.constraints = {
+		.min_uV = 3300000,
+		.max_uV = 3300000,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+		.always_on = true,
+		.apply_uV = true,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(am3517_crane_vdd2_supplies),
+	.consumer_supplies = am3517_crane_vdd2_supplies,
+};
+
+
+static struct regulator_consumer_supply am3517_crane_vio_supplies[] = {
+	{
+		.supply = "vdds",
+	},
+};
+
+static struct regulator_init_data am3517_crane_regulator_vio = {
+	.constraints = {
+		.min_uV = 1800000,
+		.max_uV = 1800000,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+		.always_on = true,
+		.apply_uV = true,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(am3517_crane_vio_supplies),
+	.consumer_supplies = am3517_crane_vio_supplies,
+};
+
+
+static struct regulator_consumer_supply am3517_crane_vaux1_supplies[] = {
+	{
+		.supply = "vdd_sram_mpu",
+	},
+	{
+		.supply = "vdd_sram_core_bg0",
+	},
+	{
+		.supply = "vddsosc",
+	},
+};
+
+static struct regulator_init_data am3517_crane_regulator_vaux1 = {
+	.constraints = {
+		.min_uV = 1800000,
+		.max_uV = 1800000,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+		.always_on = true,
+		.apply_uV = true,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(am3517_crane_vaux1_supplies),
+	.consumer_supplies = am3517_crane_vaux1_supplies,
+};
+
+
+static struct regulator_consumer_supply am3517_crane_vaux2_supplies[] = {
+	{
+		.supply = "vdda1p8v_usbphy",
+	},
+};
+
+static struct regulator_init_data am3517_crane_regulator_vaux2 = {
+	.constraints = {
+		.min_uV = 1800000,
+		.max_uV = 1800000,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+		.always_on = true,
+		.apply_uV = true,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(am3517_crane_vaux2_supplies),
+	.consumer_supplies = am3517_crane_vaux2_supplies,
+};
+
+
+static struct regulator_consumer_supply am3517_crane_vdac_supplies[] = {
+	{
+		.supply = "vdda_dac",
+		.dev    = &am3517_crane_dss_device.dev,
+	},
+};
+
+static struct regulator_init_data am3517_crane_regulator_vdac = {
+	.constraints = {
+		.min_uV = 1800000,
+		.max_uV = 1800000,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.valid_ops_mask = REGULATOR_CHANGE_MODE,
+		.always_on = true,
+		.apply_uV = true,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(am3517_crane_vdac_supplies),
+	.consumer_supplies = am3517_crane_vdac_supplies,
+};
+
+static struct regulator_consumer_supply am3517_crane_vmmc_supplies[] = {
+	{
+		.supply = "vdda3p3v_usbphy",
+	},
+};
+
+static struct regulator_init_data am3517_crane_regulator_vmmc = {
+	.constraints = {
+		.min_uV = 3300000,
+		.max_uV = 3300000,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+		.always_on = true,
+		.apply_uV = true,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(am3517_crane_vmmc_supplies),
+	.consumer_supplies = am3517_crane_vmmc_supplies,
+};
+
+
+static struct regulator_consumer_supply am3517_crane_vpll_supplies[] = {
+	{
+		.supply = "vdds_dpll_mpu_usbhost",
+	},
+	{
+		.supply = "vdds_dpll_per_core",
+	},
+};
+
+static struct regulator_init_data am3517_crane_regulator_vpll = {
+	.constraints = {
+		.min_uV = 1800000,
+		.max_uV = 1800000,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+		.always_on = true,
+		.apply_uV = true,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(am3517_crane_vpll_supplies),
+	.consumer_supplies = am3517_crane_vpll_supplies,
+};
+
+static int am3517_crane_tps65910_config(struct tps65910_platform_data *pdata)
+{
+	u8 val 	= 0;
+	int i 	= 0;
+	int err = -1;
+
+
+	/* Configure TPS65910 for am3517_crane board needs */
+
+	/* Set sleep state active high */
+	val |= (TPS65910_DEV2_SLEEPSIG_POL);
+
+	err = tps65910_i2c_write_u8(TPS65910_I2C_ID0, val,
+			TPS65910_REG_DEVCTRL2);
+	if (err) {
+		printk(KERN_ERR "Unable to write TPS65910_REG_DEVCTRL2 reg\n");
+		return -EIO;
+	}
+
+	/* Mask ALL interrupts */
+	err = tps65910_i2c_write_u8(TPS65910_I2C_ID0, 0xFF,
+			TPS65910_REG_INT_MSK);
+	if (err) {
+		printk(KERN_ERR "Unable to write TPS65910_REG_INT_MSK reg\n");
+		return -EIO;
+	}
+	err = tps65910_i2c_write_u8(TPS65910_I2C_ID0, 0x03,
+			TPS65910_REG_INT_MSK2);
+	if (err) {
+		printk(KERN_ERR "Unable to write TPS65910_REG_INT_MSK2 reg\n");
+		return -EIO;
+	}
+
+	/* Set RTC regulator on during sleep */
+
+	val = TPS65910_VRTC_OFFMASK;
+	err = tps65910_i2c_write_u8(TPS65910_I2C_ID0, val,
+			TPS65910_REG_VRTC);
+
+	if (err) {
+		printk(KERN_ERR "Unable to write TPS65910_REG_VRTC reg\n");
+		return -EIO;
+	}
+	/* Set RTC Power, disable Smart Reflex in DEVCTRL_REG */
+	val = 0;
+	val &= ~TPS65910_RTC_PWDNN;
+	val |= (TPS65910_CK32K_CTRL | TPS65910_SR_CTL_I2C_SEL);
+
+	err = tps65910_i2c_write_u8(TPS65910_I2C_ID0, val,
+			TPS65910_REG_DEVCTRL);
+	if (err) {
+		printk(KERN_ERR "Unable to write TPS65910_REG_DEVCTRL reg\n");
+		return -EIO;
+	}
+
+	/* Enable and set back-up battery charger control*/
+
+	tps65910_enable_bbch(TPS65910_BBSEL_2P52);
+
+	err = tps65910_i2c_read_u8(TPS65910_I2C_ID0, &val,
+			TPS65910_REG_VRTC);
+	if (err) {
+		printk(KERN_ERR "Unable to read  TPS65910_REG_VRTC reg\n");
+		return -EIO;
+	}
+	val = TPS65910_VRTC_OFFMASK;
+
+	err = tps65910_i2c_write_u8(TPS65910_I2C_ID0, val,
+			TPS65910_REG_VRTC);
+	if (err) {
+		printk(KERN_ERR "Unable to write TPS65910_REG_VRTC reg\n");
+		return -EIO;
+	}
+
+	/* Disable SmartReflex control */
+	val &= 0;
+	val &= ~TPS65910_RTC_PWDNN;
+	val |= (TPS65910_CK32K_CTRL | TPS65910_SR_CTL_I2C_SEL);
+
+	err = tps65910_i2c_write_u8(TPS65910_I2C_ID0, val,
+			TPS65910_REG_DEVCTRL);
+	if (err) {
+		printk(KERN_ERR "Unabale to write TPS65910_REG_DEVCTRL reg\n");
+		return -EIO;
+	}
+
+	/* initilize all ISR work as NULL, specific driver will
+	 * assign function(s) later.
+	 */
+	for (i = 0; i < TPS65910_MAX_IRQS; i++)
+		pdata->handlers[i] = NULL;
+
+	return 0;
+}
+
+struct tps65910_platform_data am3517_crane_tps65910_data = {
+	.irq_num 	= (unsigned)TPS65910_HOST_IRQ,
+	.gpio  		= NULL,
+	.vio   		= &am3517_crane_regulator_vio,
+	.vdd1  		= &am3517_crane_regulator_vdd1,
+	.vdd2  		= &am3517_crane_regulator_vdd2,
+	.vdd3  		= NULL,
+	.vdig1		= NULL,
+	.vdig2		= NULL,
+	.vaux33		= NULL,
+	.vmmc		= &am3517_crane_regulator_vmmc,
+	.vaux1		= &am3517_crane_regulator_vaux1,
+	.vaux2		= &am3517_crane_regulator_vaux2,
+	.vdac		= &am3517_crane_regulator_vdac,
+	.vpll		= &am3517_crane_regulator_vpll,
+	.board_tps65910_config = am3517_crane_tps65910_config,
+};
+
+static struct i2c_board_info __initdata am3517crane_i2c1_boardinfo[] = {
+	{
+		I2C_BOARD_INFO("tps65910", TPS65910_I2C_ID0),
+		.flags          = I2C_CLIENT_WAKE,
+		.irq            = TPS65910_HOST_IRQ,
+		.platform_data  = &am3517_crane_tps65910_data,
+	},
+};
+
+
+static int __init am3517_crane_i2c_init(void)
+{
+	omap_register_i2c_bus(1, 400, am3517crane_i2c1_boardinfo,
+			ARRAY_SIZE(am3517crane_i2c1_boardinfo));
+	omap_register_i2c_bus(2, 400, NULL, 0);
+	omap_register_i2c_bus(3, 400, NULL, 0);
+
+	return 0;
+}
+
+/*
+ * HECC information
+ */
+static struct resource am3517_hecc_resources[] = {
+	{
+		.start  = AM35XX_IPSS_HECC_BASE,
+		.end    = AM35XX_IPSS_HECC_BASE + 0x3FFF,
+		.flags  = IORESOURCE_MEM,
+	},
+	{
+		.start  = INT_35XX_HECC0_IRQ,
+		.end    = INT_35XX_HECC0_IRQ,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device am3517_hecc_device = {
+	.name           = "ti_hecc",
+	.id             = 1,
+	.num_resources  = ARRAY_SIZE(am3517_hecc_resources),
+	.resource       = am3517_hecc_resources,
+};
+
+static struct ti_hecc_platform_data am3517_crane_hecc_pdata = {
+	.scc_hecc_offset        = AM35XX_HECC_SCC_HECC_OFFSET,
+	.scc_ram_offset         = AM35XX_HECC_SCC_RAM_OFFSET,
+	.hecc_ram_offset        = AM35XX_HECC_RAM_OFFSET,
+	.mbx_offset            = AM35XX_HECC_MBOX_OFFSET,
+	.int_line               = AM35XX_HECC_INT_LINE,
+	.version                = AM35XX_HECC_VERSION,
+};
+
+static void am3517_crane_hecc_init(struct ti_hecc_platform_data *pdata)
+{
+	am3517_hecc_device.dev.platform_data = pdata;
+	platform_device_register(&am3517_hecc_device);
+}
+
+
+/*
+ * Board initialization
+ */
+static struct omap_board_config_kernel am3517_crane_config[] __initdata = {
+};
+
+static struct platform_device *am3517_crane_devices[] __initdata = {
+	&dm644x_ccdc_dev,
+	&am3517_crane_dss_device,
+};
+
+static void __init am3517_crane_init_irq(void)
+{
+	omap_board_config = am3517_crane_config;
+	omap_board_config_size = ARRAY_SIZE(am3517_crane_config);
+
+	omap2_init_common_hw(NULL, NULL, NULL, NULL, NULL);
+	omap_init_irq();
+	omap_gpio_init();
+}
+
+static struct ehci_hcd_omap_platform_data ehci_pdata __initdata = {
+	.port_mode[0] = EHCI_HCD_OMAP_MODE_PHY,
+	.port_mode[1] = EHCI_HCD_OMAP_MODE_UNKNOWN,
+	.port_mode[2] = EHCI_HCD_OMAP_MODE_UNKNOWN,
+
+	.phy_reset  = true,
+	.reset_gpio_port[0]  = 38,
+	.reset_gpio_port[1]  = -EINVAL,
+	.reset_gpio_port[2]  = -EINVAL
+};
+
+#ifdef CONFIG_OMAP_MUX
+static struct omap_board_mux board_mux[] __initdata = {
+	/* USB OTG DRVVBUS offset = 0x212 */
+	OMAP3_MUX(CHASSIS_DMAREQ3, OMAP_MUX_MODE0 | OMAP_PIN_INPUT_PULLDOWN),
+	OMAP3_MUX(MCBSP_CLKS, OMAP_MUX_MODE4 | OMAP_PIN_INPUT_PULLUP),
+	OMAP3_MUX(GPMC_NCS4, OMAP_MUX_MODE4 | OMAP_PIN_INPUT_PULLDOWN),
+	{ .reg_offset = OMAP_MUX_TERMINATOR },
+};
+#else
+#define board_mux       NULL
+#endif
+
+static struct am3517_hsmmc_info mmc[] = {
+	{
+		.mmc            = 1,
+		.wires          = 8,
+		.gpio_cd        = 41,
+		.gpio_wp        = 40,
+	},
+	{}      /* Terminator */
+};
+
+static void __init am3517_crane_init(void)
+{
+
+	am3517_crane_i2c_init();
+	omap3_mux_init(board_mux, OMAP_PACKAGE_CBB);
+	platform_add_devices(am3517_crane_devices,
+			ARRAY_SIZE(am3517_crane_devices));
+
+	omap_serial_init();
+	am3517crane_flash_init();
+	usb_musb_init();
+
+	/* Configure GPIO for EHCI port */
+	omap_mux_init_gpio(35, OMAP_PIN_OUTPUT);
+	gpio_request(35, "usb_ehci_enable");
+	gpio_direction_output(35, 1);
+	gpio_set_value(35, 1);
+	omap_mux_init_gpio(38, OMAP_PIN_OUTPUT);
+	usb_ehci_init(&ehci_pdata);
+
+	/* DSS */
+	am3517_crane_display_init();
+
+	/*Ethernet*/
+	am3517_crane_ethernet_init(&am3517_crane_emac_pdata);
+	am3517_crane_hecc_init(&am3517_crane_hecc_pdata);
+
+	/* MMC init function */
+	am3517_mmc_init(mmc);
+
+}
+
+static void __init am3517_crane_map_io(void)
+{
+	omap2_set_globals_343x();
+	omap2_map_common_io();
+}
+
+MACHINE_START(CRANEBOARD, "AM3517/05 CRANEBOARD")
+	.phys_io	= 0x48000000,
+	.io_pg_offst	= ((0xd8000000) >> 18) & 0xfffc,
+	.boot_params	= 0x80000100,
+	.map_io		= am3517_crane_map_io,
+	.init_irq	= am3517_crane_init_irq,
+	.init_machine	= am3517_crane_init,
+	.timer		= &omap_timer,
+MACHINE_END
diff --git a/arch/arm/mach-omap2/mmc-am3517crane.c b/arch/arm/mach-omap2/mmc-am3517crane.c
new file mode 100644
index 0000000..80ad8ae
--- /dev/null
+++ b/arch/arm/mach-omap2/mmc-am3517crane.c
@@ -0,0 +1,267 @@
+/*
+ * linux/arch/arm/mach-omap2/mmc-crane.c
+ *
+ * Copyright (C) 2010 Mistral Solutions Pvt Ltd <www.mistralsolutions.com>
+ * Author: Srinath.R <srinath@mistralsolutions.com>
+ *
+ * Based on linux/arch/arm/mach-omap2/mmc-am3517evm.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+
+#include <mach/hardware.h>
+#include <plat/control.h>
+#include <plat/mmc.h>
+#include <plat/board.h>
+#include "mmc-am3517crane.h"
+
+#define LDO_CLR			0x00
+#define VSEL_S2_CLR		0x40
+
+#define VMMC1_DEV_GRP		0x27
+#define VMMC1_CLR		0x00
+#define VMMC1_315V		0x03
+#define VMMC1_300V		0x02
+#define VMMC1_285V		0x01
+#define VMMC1_185V		0x00
+#define VMMC1_DEDICATED		0x2A
+
+#define VMMC2_DEV_GRP		0x2B
+#define VMMC2_CLR		0x40
+#define VMMC2_315V		0x0c
+#define VMMC2_300V		0x0b
+#define VMMC2_285V		0x0a
+#define VMMC2_260V		0x08
+#define VMMC2_185V		0x06
+#define VMMC2_DEDICATED		0x2E
+
+#define VMMC_DEV_GRP_P1		0x20
+
+#define HSMMC_NAME_LEN	9
+
+#if defined(CONFIG_REGULATOR) || \
+	(defined(CONFIG_MMC_OMAP) || defined(CONFIG_MMC_OMAP_MODULE) || \
+	 defined(CONFIG_MMC_OMAP_HS) || defined(CONFIG_MMC_OMAP_HS_MODULE))
+
+/*
+ * MMC definitions
+ *
+ */
+static struct mmc_controller {
+	struct omap_mmc_platform_data	*mmc;
+	u8		vmmc_dev_grp;
+	u8		vmmc_dedicated;
+	char		name[HSMMC_NAME_LEN];
+} hsmmc[] = {
+	{
+		.vmmc_dev_grp		= VMMC1_DEV_GRP,
+		.vmmc_dedicated		= VMMC1_DEDICATED,
+	},
+	{
+		.vmmc_dev_grp		= VMMC2_DEV_GRP,
+		.vmmc_dedicated		= VMMC2_DEDICATED,
+	},
+};
+
+static int mmc_card_detect(int irq)
+{
+	unsigned i;
+
+	for (i = 0; i < ARRAY_SIZE(hsmmc); i++) {
+		struct omap_mmc_platform_data *mmc;
+
+		mmc = hsmmc[i].mmc;
+		if (!mmc)
+			continue;
+		if (irq != mmc->slots[0].card_detect_irq)
+			continue;
+
+		/* NOTE: assumes card detect signal is active-low */
+		return !gpio_get_value_cansleep(mmc->slots[0].switch_pin);
+	}
+	return -ENOSYS;
+}
+
+static int mmc_get_ro(struct device *dev, int slot)
+{
+	struct omap_mmc_platform_data *mmc = dev->platform_data;
+
+	/* NOTE: assumes write protect signal is active-high */
+	return gpio_get_value_cansleep(mmc->slots[0].gpio_wp);
+}
+
+/*
+ * MMC Slot Initialization.
+ */
+static int mmc_late_init(struct device *dev)
+{
+	struct omap_mmc_platform_data *mmc = dev->platform_data;
+	int ret = 0;
+	int i;
+
+	ret = gpio_request(mmc->slots[0].switch_pin, "mmc_cd");
+	if (ret)
+		goto done;
+	ret = gpio_direction_input(mmc->slots[0].switch_pin);
+	if (ret)
+		goto err;
+
+	for (i = 0; i < ARRAY_SIZE(hsmmc); i++) {
+		if (hsmmc[i].name == mmc->slots[0].name) {
+			hsmmc[i].mmc = mmc;
+			break;
+		}
+	}
+
+	return 0;
+
+err:
+	gpio_free(mmc->slots[0].switch_pin);
+done:
+	mmc->slots[0].card_detect_irq = 0;
+	mmc->slots[0].card_detect = NULL;
+
+	dev_err(dev, "err %d configuring card detect\n", ret);
+	return ret;
+}
+
+static void mmc_cleanup(struct device *dev)
+{
+	struct omap_mmc_platform_data *mmc = dev->platform_data;
+
+	gpio_free(mmc->slots[0].switch_pin);
+}
+
+#ifdef CONFIG_PM
+
+static int mmc_suspend(struct device *dev, int slot)
+{
+	struct omap_mmc_platform_data *mmc = dev->platform_data;
+
+	disable_irq(mmc->slots[0].card_detect_irq);
+	return 0;
+}
+
+static int mmc_resume(struct device *dev, int slot)
+{
+	struct omap_mmc_platform_data *mmc = dev->platform_data;
+
+	enable_irq(mmc->slots[0].card_detect_irq);
+	return 0;
+}
+
+#else
+#define mmc_suspend	NULL
+#define mmc_resume	NULL
+#endif
+
+/*
+ * the MMC power setting function
+ */
+
+static int mmc1_set_power(struct device *dev, int slot, int power_on,
+				int vdd)
+{
+	return 0;
+}
+
+static int mmc2_set_power(struct device *dev, int slot, int power_on, int vdd)
+{
+	return 0;
+}
+
+static struct omap_mmc_platform_data *hsmmc_data[OMAP34XX_NR_MMC] __initdata;
+
+void __init am3517_mmc_init(struct am3517_hsmmc_info *controllers)
+{
+	struct am3517_hsmmc_info *c;
+	int nr_hsmmc = ARRAY_SIZE(hsmmc_data);
+
+	for (c = controllers; c->mmc; c++) {
+		struct mmc_controller *mmc_control = hsmmc + c->mmc - 1;
+		struct omap_mmc_platform_data *mmc = hsmmc_data[c->mmc - 1];
+
+		if (!c->mmc || c->mmc > nr_hsmmc) {
+			pr_debug("MMC%d: no such controller\n", c->mmc);
+			continue;
+		}
+		if (mmc) {
+			pr_debug("MMC%d: already configured\n", c->mmc);
+			continue;
+		}
+
+		mmc = kzalloc(sizeof(struct omap_mmc_platform_data),
+					GFP_KERNEL);
+		if (!mmc) {
+			pr_err("Cannot allocate memory for mmc device!\n");
+			return;
+		}
+
+		sprintf(mmc_control->name, "mmc%islot%i", c->mmc, 1);
+		mmc->slots[0].name = mmc_control->name;
+		mmc->nr_slots = 1;
+		mmc->slots[0].ocr_mask = MMC_VDD_165_195 |
+					MMC_VDD_26_27 | MMC_VDD_27_28 |
+					MMC_VDD_29_30 |
+					MMC_VDD_30_31 | MMC_VDD_31_32;
+		mmc->slots[0].wires = c->wires;
+		mmc->slots[0].internal_clock = !c->ext_clock;
+		mmc->dma_mask = 0xffffffff;
+
+		if (1) {
+			mmc->init = mmc_late_init;
+			mmc->cleanup = mmc_cleanup;
+			mmc->suspend = mmc_suspend;
+			mmc->resume = mmc_resume;
+
+			mmc->slots[0].switch_pin = c->gpio_cd;
+			mmc->slots[0].card_detect_irq = gpio_to_irq(c->gpio_cd);
+			mmc->slots[0].card_detect = mmc_card_detect;
+		} else
+			mmc->slots[0].switch_pin = -EINVAL;
+
+		/* write protect normally uses an OMAP gpio */
+		if (gpio_is_valid(c->gpio_wp)) {
+			gpio_request(c->gpio_wp, "mmc_wp");
+			gpio_direction_input(c->gpio_wp);
+
+			mmc->slots[0].gpio_wp = c->gpio_wp;
+			mmc->slots[0].get_ro = mmc_get_ro;
+		} else
+			mmc->slots[0].gpio_wp = -EINVAL;
+
+		/* NOTE:  we assume OMAP's MMC1 and MMC2 use
+		 * the TWL4030's VMMC1 and VMMC2, respectively;
+		 * and that OMAP's MMC3 isn't used.
+		 */
+
+		switch (c->mmc) {
+		case 1:
+			mmc->slots[0].set_power = mmc1_set_power;
+			break;
+		case 2:
+			mmc->slots[0].set_power = mmc2_set_power;
+			break;
+		default:
+			pr_err("MMC%d configuration not supported!\n", c->mmc);
+			continue;
+		}
+		hsmmc_data[c->mmc - 1] = mmc;
+	}
+
+	omap2_init_mmc(hsmmc_data, OMAP34XX_NR_MMC);
+}
+#else
+inline void am3517_mmc_init(struct craneboard_hsmmc_info *info)
+{
+}
+#endif
diff --git a/arch/arm/mach-omap2/mmc-am3517crane.h b/arch/arm/mach-omap2/mmc-am3517crane.h
new file mode 100644
index 0000000..97fd872
--- /dev/null
+++ b/arch/arm/mach-omap2/mmc-am3517crane.h
@@ -0,0 +1,22 @@
+/*
+ * MMC definitions for craneboard AM3517/05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+struct am3517_hsmmc_info {
+	u8	mmc;		/* controller 1/2/3 */
+	u8	wires;		/* 1/4/8 wires */
+	bool	transceiver;	/* MMC-2 option */
+	bool	ext_clock;	/* use external pin for input clock */
+	bool	cover_only;	/* No card detect - just cover switch */
+	int	gpio_cd;	/* or -EINVAL */
+	int	gpio_wp;	/* or -EINVAL */
+	char	*name;		/* or NULL for default */
+	struct device *dev;	/* returned: pointer to mmc adapter */
+	int	ocr_mask;	/* temporary HACK */
+};
+
+void am3517_mmc_init(struct am3517_hsmmc_info *);
diff --git a/arch/arm/mach-omap2/tps65910-pmic.c b/arch/arm/mach-omap2/tps65910-pmic.c
new file mode 100644
index 0000000..b17d662
--- /dev/null
+++ b/arch/arm/mach-omap2/tps65910-pmic.c
@@ -0,0 +1,195 @@
+/*
+ * tps65910-pmic.c
+ *
+ * Common regulator supplies and init data structs for TPS65910
+ * PMIC for AM35xx based EVMs. They can be used in various board-evm
+ * files for Am35xx based platforms using TPS65910.
+ *
+ * Copyright (C) 2010 Mistral Solutions Pvt Ltd <www.mistralsolutions.com>
+ *
+ * Based on arch/arm/mach-omap2/twl4030-pmic.c
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any kind,
+ * whether express or implied; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+/* Power domain maping for TPS65910 and AM35XX
+
+	   1.8V
+	   VIO -----------> VDDS
+
+	   1.8V
+	   VAUX1 ---------> VDDS_SRAM_CORE_BG
+				|
+				-------> VDDS_SRAM_MPU
+				|
+				-------> VDDOSC
+
+	   3.3V
+	   VDD2 ----------> VDDSHV
+
+	   1.2V
+	   VDD1 ----------> VDD_CORE
+
+	   1.8V
+	   VPLL ----------> VDDS_DPLL_PRE_CORE
+				|
+				-------> VDDSPLL_MPU_USBHOST
+
+	   1.8V
+	   VDAC ----------> VDDA_DAC
+
+	   1.8V
+	   VAUX2 ----------> VDDA1P8V_USBPHY
+
+	   3.3V
+	   VMMC ----------> VDDA3P3V_USBPHY
+
+*/
+#include <linux/regulator/machine.h>
+
+/* VIO */
+struct regulator_consumer_supply tps65910_vio_supply = {
+	.supply = "vdds",
+};
+
+
+/* VAUX1 */
+struct regulator_consumer_supply tps65910_vaux1_supply[] = {
+	{
+		.supply = "vdds_sram_core_bg",
+	},
+	{
+		.supply = "vdds_sram_mpu",
+	},
+	{
+		.supply = "vddosc",
+	},
+};
+
+/* VPLL */
+struct regulator_consumer_supply tps65910_vpll_supply[] = {
+	{
+		.supply = "vdds_dpll_pre_core",
+	},
+	{
+		.supply = "vddspll_mpu_usbhost",
+	},
+
+};
+
+/* VDAC */
+struct regulator_consumer_supply tps65910_vdac_supply = {
+	.supply = "vdda_dac",
+};
+
+/* VAUX2 */
+struct regulator_consumer_supply tps65910_vaux2_supply = {
+	.supply = "vdda1p8v_usbphy",
+};
+
+
+/* VMMC */
+struct regulator_consumer_supply tps65910_vmmc_supply = {
+	.supply = "vdda3p3v_usbphy",
+};
+
+
+/* Regulator initialization data */
+
+/* VIO  LDO */
+struct regulator_init_data vio_data = {
+	.constraints = {
+		.min_uV = 1800000,
+		.max_uV = 1800000,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+		.always_on = true,
+		.apply_uV = true,
+	},
+	.num_consumer_supplies  = ARRAY_SIZE(tps65910_vaux1_supply),
+	.consumer_supplies      = &tps65910_vaux1_supply,
+};
+
+
+
+/* VAUX1  LDO */
+struct regulator_init_data vaux1_data = {
+	.constraints = {
+		.min_uV = 1800000,
+		.max_uV = 2850000,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+		.always_on = true,
+		.apply_uV = false,
+	},
+	.num_consumer_supplies  = ARRAY_SIZE(tps65910_vaux1_supply),
+	.consumer_supplies      = &tps65910_vaux1_supply,
+};
+
+/* VAUX2  LDO */
+struct regulator_init_data vaux2_data = {
+	.constraints = {
+		.min_uV = 3300000,
+		.max_uV = 3300000,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+		.always_on = true,
+		.apply_uV = true,
+	},
+	.num_consumer_supplies  = ARRAY_SIZE(tps65910_vaux2_supply),
+	.consumer_supplies      = &tps65910_vaux2_supply,
+
+};
+
+/* VMMC  LDO */
+struct regulator_init_data vmmc_data = {
+	.constraints = {
+		.min_uV = 1800000,
+		.max_uV = 3300000,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+		.always_on = true,
+		.apply_uV = false,
+	},
+	.num_consumer_supplies  = ARRAY_SIZE(tps65910_vmmc_supply),
+	.consumer_supplies      = &tps65910_vmmc_supply,
+
+};
+
+/* VPLL  LDO */
+struct regulator_init_data vpll_data = {
+	.constraints = {
+		.min_uV = 100000,
+		.max_uV = 2500000,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+		.always_on = true,
+		.apply_uV = false,
+	},
+	.num_consumer_supplies  = ARRAY_SIZE(tps65910_vpll_supply),
+	.consumer_supplies      = &tps65910_vpll_supply,
+};
+
+/* VDAC  LDO */
+struct regulator_init_data vdac_data = {
+	.constraints = {
+		.min_uV = 1800000,
+		.max_uV = 2850000,
+		.valid_modes_mask = REGULATOR_MODE_NORMAL
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+		.always_on = true,
+		.apply_uV = false,
+	},
+	.num_consumer_supplies  = ARRAY_SIZE(tps65910_vdac_supply),
+	.consumer_supplies      = &tps65910_vdac_supply,
+
+};
+
+
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index 07b976d..2c9a874 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -2536,3 +2536,4 @@ c3ax03			MACH_C3AX03		C3AX03			2549
 mxt_td60		MACH_MXT_TD60		MXT_TD60		2550
 esyx			MACH_ESYX		ESYX			2551
 bulldog			MACH_BULLDOG		BULLDOG			2553
+craneboard		MACH_CRANEBOARD		CRANEBOARD		2932
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index 270b6d7..b7ae0c4 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -20,3 +20,4 @@ obj-$(CONFIG_GPIO_CS5535)	+= cs5535-gpio.o
 obj-$(CONFIG_GPIO_BT8XX)	+= bt8xxgpio.o
 obj-$(CONFIG_GPIO_VR41XX)	+= vr41xx_giu.o
 obj-$(CONFIG_GPIO_WM831X)	+= wm831x-gpio.o
+
diff --git a/drivers/i2c/busses/i2c-omap.c b/drivers/i2c/busses/i2c-omap.c
index bbea8a0..48273d7 100644
--- a/drivers/i2c/busses/i2c-omap.c
+++ b/drivers/i2c/busses/i2c-omap.c
@@ -801,7 +801,7 @@ complete:
 							"data to send\n");
 					break;
 				}
-
+#ifndef CONFIG_CRANEBOARD
 				/*
 				 * OMAP3430 Errata 1.153: When an XRDY/XDR
 				 * is hit, wait for XUDF before writing data
@@ -821,6 +821,7 @@ complete:
 							stat = omap_i2c_read_reg(dev, OMAP_I2C_STAT_REG);
 						}
 				}
+#endif

 				omap_i2c_write_reg(dev, OMAP_I2C_DATA_REG, w);
 			}
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index 8782978..306b346 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -129,12 +129,25 @@ config TWL4030_POWER
 	  and load scripts controling which resources are switched off/on
 	  or reset when a sleep, wakeup or warm reset event occurs.

+config TPS65910_CORE
+	bool "Texas Instruments TPS65910 Support"
+	depends on I2C=y && GENERIC_HARDIRQS
+	help
+	  Say yes here if you have TPS65910 family chip on your board.
+	  This core driver provides register access and registers devices
+          for the various functions so that function-specific drivers can
+          bind to them.
+
+	  These multi-function chips are found on many AM35xx boards,
+          providing power management, RTC, GPIO features.
+
 config TWL4030_CODEC
 	bool
 	depends on TWL4030_CORE
 	select MFD_CORE
 	default n

+
 config MFD_TMIO
 	bool
 	default n
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index ca2f2c4..85dc3a7 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -30,6 +30,8 @@ obj-$(CONFIG_TWL4030_CORE)	+= twl-core.o twl4030-irq.o twl6030-irq.o
 obj-$(CONFIG_TWL4030_POWER)    += twl4030-power.o
 obj-$(CONFIG_TWL4030_CODEC)	+= twl4030-codec.o

+obj-$(CONFIG_TPS65910_CORE)     += tps65910-core.o
+
 obj-$(CONFIG_MFD_MC13783)	+= mc13783-core.o

 obj-$(CONFIG_MFD_CORE)		+= mfd-core.o
@@ -55,4 +57,4 @@ obj-$(CONFIG_AB3100_CORE)	+= ab3100-core.o
 obj-$(CONFIG_AB3100_OTP)	+= ab3100-otp.o
 obj-$(CONFIG_AB4500_CORE)	+= ab4500-core.o
 obj-$(CONFIG_MFD_88PM8607)	+= 88pm8607.o
-obj-$(CONFIG_PMIC_ADP5520)	+= adp5520.o
\ No newline at end of file
+obj-$(CONFIG_PMIC_ADP5520)	+= adp5520.o
diff --git a/drivers/mfd/tps65910-core.c b/drivers/mfd/tps65910-core.c
new file mode 100644
index 0000000..9ffccc7
--- /dev/null
+++ b/drivers/mfd/tps65910-core.c
@@ -0,0 +1,741 @@
+/*
+ * tps65910-core.c -- Multifunction core driver for  TPS65910x chips
+ *
+ * Copyright (C) 2010 Mistral solutions Pvt Ltd <www.mistralsolutions.com>
+ *
+ * Based on twl-core.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <linux/init.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+
+#include <linux/regulator/machine.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c/tps65910.h>
+#include <plat/board.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+
+#if defined(CONFIG_ARCH_OMAP2) || defined(CONFIG_ARCH_OMAP3)
+#include <plat/cpu.h>
+#endif
+
+#define DRIVER_NAME			"tps65910"
+
+#if defined(CONFIG_GPIO_TPS65910)
+#define tps65910_has_gpio()  		true
+#else
+#define tps65910_has_gpio()  		false
+#endif
+
+#if defined(CONFIG_REGULATOR_TPS65910)
+#define tps65910_has_regulator()     	true
+#else
+#define tps65910_has_regulator()     	false
+#endif
+
+#if defined(CONFIG_RTC_DRV_TPS65910)
+#define tps65910_has_rtc()   		true
+#else
+#define tps65910_has_rtc()   		false
+#endif
+
+#define TPS65910_GENERAL		0
+#define TPS65910_SMARTREFLEX		1
+
+
+struct tps65910_platform_data *the_tps65910;
+
+enum tps65910x_model {
+	TPS65910,   	/* TI processors OMAP3 family */
+	TPS659101,  	/* Samsung - S5PV210, S5PC1xx */
+	TPS659102,	/* Samsung - S3C64xx */
+	TPS659103,	/* Reserved */
+	TPS659104,	/* Reserved */
+	TPS659105,	/* TI processors - DM643x, DM644x */
+	TPS659106,	/* Reserved */
+	TPS659107,	/* Reserved */
+	TPS659108,	/* Reserved */
+	TPS659109,	/* Freescale - i.MX51 */
+
+};
+
+static bool inuse;
+static struct work_struct core_work;
+static struct mutex work_lock;
+
+/* Structure for each TPS65910 Slave */
+struct tps65910_client {
+	struct i2c_client *client;
+	u8 address;
+	/* max numb of i2c_msg required for read = 2 */
+	struct i2c_msg xfer_msg[2];
+	/* To lock access to xfer_msg */
+	struct mutex xfer_lock;
+};
+static struct tps65910_client tps65910_modules[TPS65910_NUM_SLAVES];
+
+/* bbch = Back-up battery charger control register */
+int tps65910_enable_bbch(u8 voltage)
+{
+
+	u8 val = 0;
+	int err;
+
+	if (voltage == TPS65910_BBSEL_3P0 || voltage == TPS65910_BBSEL_2P52 ||
+			voltage == TPS65910_BBSEL_3P15 ||
+			voltage == TPS65910_BBSEL_VBAT) {
+		val = (voltage | TPS65910_BBCHEN);
+		err = tps65910_i2c_write_u8(TPS65910_I2C_ID0, val,
+				TPS65910_REG_BBCH);
+		if (err) {
+			printk(KERN_ERR "Unable write TPS65910_REG_BBCH reg\n");
+			return -EIO;
+		}
+	} else {
+		printk(KERN_ERR"Invalid argumnet for %s \n", __func__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(tps65910_enable_bbch);
+
+int tps65910_disable_bbch(void)
+{
+
+	u8 val = 0;
+	int err;
+
+	err = tps65910_i2c_read_u8(TPS65910_I2C_ID0, &val, TPS65910_REG_BBCH);
+
+	if (!err) {
+		val &= ~TPS65910_BBCHEN;
+
+		err = tps65910_i2c_write_u8(TPS65910_I2C_ID0, val,
+				TPS65910_REG_BBCH);
+		if (err) {
+			printk(KERN_ERR "Unable write TPS65910_REG_BBCH \
+					reg\n");
+			return -EIO;
+		}
+	} else {
+		printk(KERN_ERR "Unable to read TPS65910_REG_BBCH reg\n");
+		return -EIO;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(tps65910_disable_bbch);
+
+int tps65910_i2c_read(u8 slave_addr, u8 *value, u8 reg, unsigned num_bytes)
+{
+	u8 		val;
+	u32 		ret;
+	struct 		tps65910_client *tps65910;
+	struct i2c_msg *msg;
+
+	switch (slave_addr) {
+	case TPS65910_I2C_ID0:
+		tps65910 = &tps65910_modules[0];
+		tps65910->address = TPS65910_I2C_ID0;
+		break;
+	case TPS65910_I2C_ID1:
+		tps65910 = &tps65910_modules[1];
+		tps65910->address = TPS65910_I2C_ID1;
+		break;
+	default:
+		printk(KERN_ERR "Invalid Slave address for TPS65910\n");
+		return -ENODEV;
+	}
+	mutex_lock(&tps65910->xfer_lock);
+	/* [MSG1] fill the register address data */
+	msg = &tps65910->xfer_msg[0];
+	msg->addr = tps65910->address;
+	msg->len = 1;
+	msg->flags = 0;
+	val = reg;
+	msg->buf = &val;
+	/* [MSG2] fill the data rx buffer */
+	msg = &tps65910->xfer_msg[1];
+	msg->addr = tps65910->address;
+	msg->flags = I2C_M_RD;  /* Read the register value */
+	msg->len = num_bytes;   /* only n bytes */
+	msg->buf = value;
+
+	ret = i2c_transfer(tps65910->client->adapter, tps65910->xfer_msg, 2);
+	mutex_unlock(&tps65910->xfer_lock);
+
+	/* i2c_transfer returns number of messages transferred */
+	if (ret != 2) {
+		pr_err("%s: i2c_read failed to transfer all messages\n",
+				"TPS65910C");
+		return -EIO;
+	} else {
+		return 0;
+	}
+}
+EXPORT_SYMBOL(tps65910_i2c_read);
+
+
+int tps65910_i2c_write(u8 slave_addr, u8 *value, u8 reg, unsigned num_bytes)
+{
+	int ret;
+	struct tps65910_client *tps65910;
+	struct i2c_msg *msg;
+	u8 write_buf[66]; /* Max 65 Regs + offset*/
+
+	switch (slave_addr) {
+	case TPS65910_I2C_ID0:
+		tps65910 = &tps65910_modules[0];
+		tps65910->address = TPS65910_I2C_ID0;
+		break;
+	case TPS65910_I2C_ID1:
+		tps65910 = &tps65910_modules[1];
+		tps65910->address = TPS65910_I2C_ID1;
+		break;
+	default:
+		printk(KERN_ERR "Invalid Slave address for TPS65910\n");
+		return -ENODEV;
+	}
+
+	mutex_lock(&tps65910->xfer_lock);
+	/* [MSG1]: fill the register address data fill the data Tx buffer */
+	msg = &tps65910->xfer_msg[0];
+	msg->addr = tps65910->address;
+	msg->len = num_bytes + 1;
+	msg->flags = 0;
+	write_buf[0] = reg;
+	memcpy(&write_buf[1], value, num_bytes);
+	msg->buf = &write_buf[0];
+	ret = i2c_transfer(tps65910->client->adapter, tps65910->xfer_msg, 1);
+	mutex_unlock(&tps65910->xfer_lock);
+
+	/* i2c_transfer returns number of messages transferred */
+	if (ret != 1) {
+		pr_err("%s: i2c_write failed to transfer all messages\n",
+				__func__);
+		return -EIO;
+	} else {
+		return 0;
+	}
+}
+EXPORT_SYMBOL(tps65910_i2c_write);
+
+int tps65910_i2c_read_u8(u8 mod_no, u8 *value, u8 reg)
+{
+	struct tps65910_client *tps65910;
+
+	switch (mod_no) {
+	case TPS65910_I2C_ID0:
+		tps65910 = &tps65910_modules[0];
+		tps65910->address = TPS65910_I2C_ID0;
+		break;
+	case TPS65910_I2C_ID1:
+		tps65910 = &tps65910_modules[1];
+		tps65910->address = TPS65910_I2C_ID1;
+		break;
+	default:
+		printk(KERN_ERR "Invalid Slave address for TPS65910\n");
+		return -ENODEV;
+	}
+
+	(*value) = i2c_smbus_read_byte_data(tps65910->client, reg);
+	mdelay(10);
+	if (*value < 0)
+		return -EIO;
+	else
+		return 0;
+}
+EXPORT_SYMBOL(tps65910_i2c_read_u8);
+
+int tps65910_i2c_write_u8(u8 slave_addr, u8 value, u8 reg)
+{
+	int 			ret;
+	struct tps65910_client *tps65910;
+
+	switch (slave_addr) {
+	case TPS65910_I2C_ID0:
+		tps65910 = &tps65910_modules[0];
+		tps65910->address = TPS65910_I2C_ID0;
+		break;
+	case TPS65910_I2C_ID1:
+		tps65910 = &tps65910_modules[1];
+		tps65910->address = TPS65910_I2C_ID1;
+		break;
+	default:
+		printk(KERN_ERR "Invalid Slave address for TPS65910\n");
+		return -ENODEV;
+	}
+	ret = i2c_smbus_write_byte_data(tps65910->client, reg, value);
+	if (ret < 0)
+		return -EIO;
+	else
+		return 0;
+}
+EXPORT_SYMBOL(tps65910_i2c_write_u8);
+
+
+int tps65910_enable_irq(int irq)
+{
+	u8  mask = 0x00;
+
+	if (irq > 7) {
+		irq -= 8;
+		tps65910_i2c_read_u8(TPS65910_I2C_ID0,
+				&mask, TPS65910_REG_INT_MSK2);
+		mask &= ~(1 << irq);
+		return tps65910_i2c_write_u8(TPS65910_I2C_ID0,
+				mask, TPS65910_REG_INT_MSK2);
+	} else {
+		tps65910_i2c_read_u8(TPS65910_I2C_ID0,
+				&mask, TPS65910_REG_INT_MSK);
+		mask &= ~(1 << irq);
+		return tps65910_i2c_write_u8(TPS65910_I2C_ID0,
+				mask, TPS65910_REG_INT_MSK);
+	}
+}
+EXPORT_SYMBOL(tps65910_enable_irq);
+
+int tps65910_disable_irq(int irq)
+{
+	u8  mask = 0x00;
+
+	if (irq > 7) {
+		irq -= 8;
+		tps65910_i2c_read_u8(TPS65910_I2C_ID0,
+				&mask, TPS65910_REG_INT_MSK2);
+		mask |= (1 << irq);
+		return tps65910_i2c_write_u8(TPS65910_I2C_ID0,
+				mask, TPS65910_REG_INT_MSK2);
+	} else {
+		tps65910_i2c_read_u8(TPS65910_I2C_ID0,
+				&mask, TPS65910_REG_INT_MSK);
+		mask = (1 << irq);
+		return tps65910_i2c_write_u8(TPS65910_I2C_ID0,
+				mask, TPS65910_REG_INT_MSK);
+	}
+}
+EXPORT_SYMBOL(tps65910_disable_irq);
+
+int tps65910_add_irq_work(int irq,
+		void (*handler)(void *data))
+{
+	int ret = 0;
+	the_tps65910->handlers[irq] = handler;
+	ret = tps65910_enable_irq(irq);
+
+	return ret;
+}
+EXPORT_SYMBOL(tps65910_add_irq_work);
+
+int tps65910_remove_irq_work(int irq)
+{
+	int ret = 0;
+	ret = tps65910_disable_irq(irq);
+	the_tps65910->handlers[irq] = NULL;
+	return ret;
+}
+EXPORT_SYMBOL(tps65910_remove_irq_work);
+
+static void tps65910_core_work(struct work_struct *work)
+{
+	/* Read the status register and take action  */
+	u8	status = 0x00;
+	u8	status2 = 0x00;
+	u8 	mask = 0x00;
+	u8 	mask2 = 0x00;
+	u16 	isr = 0x00;
+	u16 	irq = 0;
+	void	(*handler)(void *data) = NULL;
+
+	mutex_lock(&work_lock);
+	while (1) {
+		tps65910_i2c_read_u8(TPS65910_I2C_ID0, &status2,
+				TPS65910_REG_INT_STS2);
+		tps65910_i2c_read_u8(TPS65910_I2C_ID0, &mask2,
+				TPS65910_REG_INT_MSK2);
+		status2 &= (~mask2);
+		isr = (status2 << 8);
+		tps65910_i2c_read_u8(TPS65910_I2C_ID0, &status,
+				TPS65910_REG_INT_STS);
+		tps65910_i2c_read_u8(TPS65910_I2C_ID0, &mask,
+				TPS65910_REG_INT_MSK);
+		status &= ~(mask);
+		isr |= status;
+		if (!isr)
+			break;
+
+		while (isr) {
+			irq = fls(isr) - 1;
+			isr &= ~(1 << irq);
+			handler = the_tps65910->handlers[irq];
+			if (handler)
+				handler(the_tps65910);
+		}
+	}
+	enable_irq(the_tps65910->irq_num);
+	mutex_unlock(&work_lock);
+}
+
+
+static irqreturn_t tps65910_isr(int irq,  void *data)
+{
+
+#ifdef CONFIG_LOCKDEP
+	/* WORKAROUND for lockdep forcing IRQF_DISABLED on us, which
+	 * we don't want and can't tolerate.  Although it might be
+	 * friendlier not to borrow this thread context...
+	 */
+	local_irq_enable();
+#endif
+	disable_irq_nosync(irq);
+	(void) schedule_work(&core_work);
+	return IRQ_HANDLED;
+}
+
+
+static struct device *add_numbered_child(unsigned chip, const char *name,
+	int num, void *pdata, unsigned pdata_len, bool can_wakeup, int irq)
+{
+
+	struct platform_device  *pdev;
+	struct tps65910_client  *tps65910 = &tps65910_modules[chip];
+	int  status;
+
+	pdev = platform_device_alloc(name, num);
+	if (!pdev) {
+		dev_dbg(&tps65910->client->dev, "can't alloc dev\n");
+		status = -ENOMEM;
+		goto err;
+	}
+	device_init_wakeup(&pdev->dev, can_wakeup);
+	pdev->dev.parent = &tps65910->client->dev;
+
+	if (pdata) {
+		status = platform_device_add_data(pdev, pdata, pdata_len);
+		if (status < 0) {
+			dev_dbg(&pdev->dev, "can't add platform_data\n");
+			goto err;
+		}
+	}
+	status = platform_device_add(pdev);
+
+err:
+	if (status < 0) {
+		platform_device_put(pdev);
+		dev_err(&tps65910->client->dev, "can't add %s dev\n", name);
+		return ERR_PTR(status);
+	}
+	return &pdev->dev;
+
+}
+
+static inline struct device *add_child(unsigned chip, const char *name,
+		void *pdata, unsigned pdata_len,
+		bool can_wakeup, int irq)
+{
+	return add_numbered_child(chip, name, -1, pdata, pdata_len,
+			can_wakeup, irq);
+}
+	static
+struct device *add_regulator_linked(int num, struct regulator_init_data *pdata,
+		struct regulator_consumer_supply *consumers,
+		unsigned num_consumers)
+{
+	/* regulator framework demands init_data */
+	if (!pdata)
+		return NULL;
+
+	if (consumers) {
+		pdata->consumer_supplies = consumers;
+		pdata->num_consumer_supplies = num_consumers;
+	}
+	return add_numbered_child(TPS65910_GENERAL, "tps65910_regulator", num,
+			pdata, sizeof(*pdata), false, TPS65910_HOST_IRQ);
+}
+
+	static struct device *
+add_regulator(int num, struct regulator_init_data *pdata)
+{
+	return add_regulator_linked(num, pdata, NULL, 0);
+}
+
+	static int
+add_children(struct tps65910_platform_data *pdata, unsigned long features)
+{
+	int 		status;
+	struct device   *child;
+
+	struct platform_device  *pdev = NULL;
+
+	if (tps65910_has_gpio() && (pdata->gpio != NULL)) {
+
+		pdev = platform_device_alloc("tps65910_gpio", -1);
+		if (!pdev) {
+			status = -ENOMEM;
+			goto err;
+		}
+		pdev->dev.parent = &tps65910_modules[0].client->dev;
+		device_init_wakeup(&pdev->dev, 0);
+		if (pdata) {
+			status = platform_device_add_data(pdev, pdata,
+							sizeof(*pdata));
+			if (status < 0) {
+				dev_dbg(&pdev->dev,
+				"can't add platform_data\n");
+				goto err;
+			}
+		}
+	}
+	if (tps65910_has_rtc()) {
+		child = add_child(TPS65910_GENERAL, "tps65910_rtc",
+				NULL, 0, true, pdata->irq_num);
+		if (IS_ERR(child))
+			return PTR_ERR(child);
+	}
+
+	if (tps65910_has_regulator()) {
+
+		child = add_regulator(TPS65910_VIO, pdata->vio);
+		if (IS_ERR(child))
+			return PTR_ERR(child);
+
+		child = add_regulator(TPS65910_VDD1, pdata->vdd1);
+		if (IS_ERR(child))
+			return PTR_ERR(child);
+
+		child = add_regulator(TPS65910_VDD2, pdata->vdd2);
+		if (IS_ERR(child))
+			return PTR_ERR(child);
+
+		child = add_regulator(TPS65910_VDD3, pdata->vdd3);
+		if (IS_ERR(child))
+			return PTR_ERR(child);
+
+		child = add_regulator(TPS65910_VDIG1, pdata->vdig1);
+		if (IS_ERR(child))
+			return PTR_ERR(child);
+
+		child = add_regulator(TPS65910_VDIG2, pdata->vdig2);
+		if (IS_ERR(child))
+			return PTR_ERR(child);
+
+		child = add_regulator(TPS65910_VAUX33, pdata->vaux33);
+		if (IS_ERR(child))
+			return PTR_ERR(child);
+
+		child = add_regulator(TPS65910_VMMC, pdata->vmmc);
+		if (IS_ERR(child))
+			return PTR_ERR(child);
+
+		child = add_regulator(TPS65910_VAUX1, pdata->vaux1);
+		if (IS_ERR(child))
+			return PTR_ERR(child);
+
+		child = add_regulator(TPS65910_VAUX2, pdata->vaux2);
+		if (IS_ERR(child))
+			return PTR_ERR(child);
+
+		child = add_regulator(TPS65910_VDAC, pdata->vdac);
+		if (IS_ERR(child))
+			return PTR_ERR(child);
+
+		child = add_regulator(TPS65910_VPLL, pdata->vpll);
+		if (IS_ERR(child))
+			return PTR_ERR(child);
+	}
+	return 0;
+
+err:
+	return -1;
+
+}
+
+static int tps65910_remove(struct i2c_client *client)
+{
+	unsigned i;
+
+	for (i = 0; i < TPS65910_NUM_SLAVES; i++) {
+
+		struct tps65910_client *tps65910 = &tps65910_modules[i];
+
+		if (tps65910->client && tps65910->client != client)
+			i2c_unregister_device(tps65910->client);
+
+		tps65910_modules[i].client = NULL;
+	}
+	inuse = false;
+	return 0;
+}
+
+static int __init
+tps65910_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	int	 status;
+	unsigned i;
+	struct 	 tps65910_platform_data	*pdata;
+
+	pdata = client->dev.platform_data;
+	the_tps65910 = pdata;
+
+	if (!pdata) {
+		dev_dbg(&client->dev, "no platform data?\n");
+		return -EINVAL;
+	}
+
+	if (i2c_check_functionality(client->adapter,
+				(I2C_FUNC_I2C | I2C_FUNC_SMBUS_BYTE)) == 0) {
+		dev_dbg(&client->dev, "can't talk I2C?\n");
+		return -EIO;
+	}
+
+	if (inuse) {
+		dev_dbg(&client->dev, "driver is already in use\n");
+		return -EBUSY;
+	}
+
+	for (i = 0; i < TPS65910_NUM_SLAVES; i++) {
+
+		struct tps65910_client  *tps65910 = &tps65910_modules[i];
+
+		tps65910->address = client->addr + i;
+
+		if (i == 0)
+			tps65910->client = client;
+		else {
+			tps65910->client = i2c_new_dummy(client->adapter,
+					tps65910->address);
+
+			if (!tps65910->client) {
+				dev_err(&client->dev,
+						"can't attach client %d\n", i);
+				status = -ENOMEM;
+				goto fail;
+			}
+		}
+		mutex_init(&tps65910->xfer_lock);
+	}
+
+	inuse = true;
+
+	if (pdata->board_tps65910_config != NULL)
+		pdata->board_tps65910_config(pdata);
+
+
+	if (pdata->irq_num) {
+		/* TPS65910 power ON interrupt(s) would have already been
+ 		 * occured, immediately after request_irq the control will be
+ 		 * transfered to tps65910_isr, if we do work initialization
+ 		 * after requesting IRQ, the system crashes (does not boot),
+ 		 * to avoid this we do work initialization before requesting
+ 		 * IRQ
+		 */
+		mutex_init(&work_lock);
+		INIT_WORK(&core_work, tps65910_core_work);
+
+		status = request_irq(pdata->irq_num, tps65910_isr,
+					IRQF_DISABLED, "tps65910", pdata);
+		if (status < 0) {
+			pr_err("tps65910: could not claim irq%d: %d\n",
+					pdata->irq_num,	status);
+			goto fail;
+		}
+	}
+
+	status = add_children(pdata, 0x00);
+	if (status < 0)
+		goto fail;
+
+	return 0;
+
+fail:
+	if (status < 0)
+		tps65910_remove(client);
+
+	return status;
+}
+
+
+static int tps65910_i2c_remove(struct i2c_client *client)
+{
+	unsigned i;
+
+	for (i = 0; i < TPS65910_NUM_SLAVES; i++) {
+
+		struct tps65910_client	*tps65910 = &tps65910_modules[i];
+
+		if (tps65910->client && tps65910->client != client)
+			i2c_unregister_device(tps65910->client);
+
+		tps65910_modules[i].client = NULL;
+	}
+	inuse = false;
+	return 0;
+}
+
+/* chip-specific feature flags, for i2c_device_id.driver_data */
+static const struct i2c_device_id tps65910_i2c_ids[] = {
+	{ "tps65910", TPS65910 },
+	{ "tps659101", TPS659101 },
+	{ "tps659102", TPS659102 },
+	{ "tps659103", TPS659103 },
+	{ "tps659104", TPS659104 },
+	{ "tps659105", TPS659105 },
+	{ "tps659106", TPS659106 },
+	{ "tps659107", TPS659107 },
+	{ "tps659108", TPS659108 },
+	{ "tps659109", TPS659109 },
+	{/* end of list */ },
+};
+MODULE_DEVICE_TABLE(i2c, tps65910_i2c_ids);
+
+/* One Client Driver ,3 Clients - Regulator, RTC , GPIO */
+static struct i2c_driver tps65910_i2c_driver = {
+	.driver.name    = DRIVER_NAME,
+	.id_table       = tps65910_i2c_ids,
+	.probe          = tps65910_i2c_probe,
+	.remove         = tps65910_i2c_remove,
+};
+
+static int __init tps65910_init(void)
+{
+	int res;
+
+	res = i2c_add_driver(&tps65910_i2c_driver);
+	if (res < 0) {
+		pr_err(DRIVER_NAME ": driver registration failed\n");
+		return res;
+	}
+
+	return 0;
+}
+subsys_initcall(tps65910_init);
+
+static void __exit tps65910_exit(void)
+{
+	i2c_del_driver(&tps65910_i2c_driver);
+}
+module_exit(tps65910_exit);
+
+MODULE_AUTHOR("Mistral Solutions Pvt Ltd");
+MODULE_DESCRIPTION("I2C Core interface for TPS65910");
+MODULE_LICENSE("GPL");
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index 71fbd6e..0ddf4c2 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -267,6 +267,14 @@ config RTC_DRV_TWL4030
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-twl.

+config RTC_DRV_TPS65910
+	boolean "TI TPS65910"
+	depends on RTC_CLASS && TPS65910_CORE
+	help
+	  If you say yes here you get support for the RTC on the
+	  TPS65910 family chips, used mostly with OMAP3/AM35xx platforms.
+
+
 config RTC_DRV_S35390A
 	tristate "Seiko Instruments S-35390A"
 	select BITREVERSE
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index 7da6efb..8fcfe49 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -81,6 +81,7 @@ obj-$(CONFIG_RTC_DRV_STMP)	+= rtc-stmp3xxx.o
 obj-$(CONFIG_RTC_DRV_SUN4V)	+= rtc-sun4v.o
 obj-$(CONFIG_RTC_DRV_TEST)	+= rtc-test.o
 obj-$(CONFIG_RTC_DRV_TWL4030)	+= rtc-twl.o
+obj-$(CONFIG_RTC_DRV_TPS65910)	+= rtc-tps65910.o
 obj-$(CONFIG_RTC_DRV_TX4939)	+= rtc-tx4939.o
 obj-$(CONFIG_RTC_DRV_V3020)	+= rtc-v3020.o
 obj-$(CONFIG_RTC_DRV_VR41XX)	+= rtc-vr41xx.o
diff --git a/drivers/rtc/rtc-tps65910.c b/drivers/rtc/rtc-tps65910.c
new file mode 100644
index 0000000..7e7ed4b
--- /dev/null
+++ b/drivers/rtc/rtc-tps65910.c
@@ -0,0 +1,657 @@
+/*
+ * rtc-tps65910.c -- TPS65910 Real Time Clock interface
+ *
+ * Copyright (C) 2010 Mistral Solutions Pvt Ltd. <www.mistralsolutions.com>
+ * Author: Umesh K <umeshk@mistralsolutions.com>
+ *
+ * Based on rtc-twl.c
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/rtc.h>
+#include <linux/bcd.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/i2c/tps65910.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+
+/* RTC Definitions */
+/* RTC_CTRL_REG bitfields */
+#define BIT_RTC_CTRL_REG_STOP_RTC_M		0x01
+#define BIT_RTC_CTRL_REG_ROUND_30S_M		0x02
+#define BIT_RTC_CTRL_REG_AUTO_COMP_M		0x04
+#define BIT_RTC_CTRL_REG_MODE_12_24_M		0x08
+#define BIT_RTC_CTRL_REG_TEST_MODE_M		0x10
+#define BIT_RTC_CTRL_REG_SET_32_COUNTER_M	0x20
+#define BIT_RTC_CTRL_REG_GET_TIME_M		0x40
+#define BIT_RTC_CTRL_REG_RTC_V_OPT_M		0x80
+
+/* RTC_STATUS_REG bitfields */
+#define BIT_RTC_STATUS_REG_RUN_M		0x02
+#define BIT_RTC_STATUS_REG_1S_EVENT_M		0x04
+#define BIT_RTC_STATUS_REG_1M_EVENT_M		0x08
+#define BIT_RTC_STATUS_REG_1H_EVENT_M		0x10
+#define BIT_RTC_STATUS_REG_1D_EVENT_M		0x20
+#define BIT_RTC_STATUS_REG_ALARM_M		0x40
+#define BIT_RTC_STATUS_REG_POWER_UP_M		0x80
+
+/* RTC_INTERRUPTS_REG bitfields */
+#define BIT_RTC_INTERRUPTS_REG_EVERY_M		0x03
+#define BIT_RTC_INTERRUPTS_REG_IT_TIMER_M	0x04
+#define BIT_RTC_INTERRUPTS_REG_IT_ALARM_M	0x08
+
+/* DEVCTRL bitfields */
+#define BIT_RTC_PWDN				0x40
+
+/* REG_SECONDS_REG through REG_YEARS_REG is how many registers? */
+#define ALL_TIME_REGS				6
+
+/*
+ * Supports 1 byte read from TPS65910 RTC register.
+ */
+static int tps65910_rtc_read_u8(u8 *data, u8 reg)
+{
+	int ret;
+
+	ret = tps65910_i2c_read_u8(TPS65910_I2C_ID0, data, reg);
+
+	if (ret < 0)
+		pr_err("tps65910_rtc: Could not read TPS65910"
+				"register %X - error %d\n", reg, ret);
+	return ret;
+}
+
+/*
+ * Supports 1 byte write to TPS65910 RTC registers.
+ */
+static int tps65910_rtc_write_u8(u8 data, u8 reg)
+{
+	int ret;
+
+	ret = tps65910_i2c_write_u8(TPS65910_I2C_ID0, data, reg);
+	if (ret < 0)
+		pr_err("tps65910_rtc: Could not write TPS65910"
+				"register %X - error %d\n", reg, ret);
+	return ret;
+}
+
+/*
+ * Cache the value for timer/alarm interrupts register; this is
+ * only changed by callers holding rtc ops lock (or resume).
+ */
+static unsigned char rtc_irq_bits;
+
+/*
+ * Enable 1/second update and/or alarm interrupts.
+ */
+static int set_rtc_irq_bit(unsigned char bit)
+{
+	unsigned char val;
+	int ret;
+
+	val = rtc_irq_bits | bit;
+	val |= bit;
+	ret = tps65910_rtc_write_u8(val, TPS65910_REG_RTC_INTERRUPTS);
+	if (ret == 0)
+		rtc_irq_bits = val;
+
+	return ret;
+}
+
+/*
+ * Disable update and/or alarm interrupts.
+ */
+static int mask_rtc_irq_bit(unsigned char bit)
+{
+	unsigned char val;
+	int ret;
+
+	val = rtc_irq_bits & ~bit;
+	ret = tps65910_rtc_write_u8(val, TPS65910_REG_RTC_INTERRUPTS);
+	if (ret == 0)
+		rtc_irq_bits = val;
+
+	return ret;
+}
+
+static int tps65910_rtc_alarm_irq_enable(struct device *dev, unsigned enabled)
+{
+	int ret;
+
+	if (enabled)
+		ret = set_rtc_irq_bit(BIT_RTC_INTERRUPTS_REG_IT_ALARM_M);
+	else
+		ret = mask_rtc_irq_bit(BIT_RTC_INTERRUPTS_REG_IT_ALARM_M);
+
+	return ret;
+}
+
+static int tps65910_rtc_update_irq_enable(struct device *dev, unsigned enabled)
+{
+	int ret;
+
+	if (enabled)
+		ret = set_rtc_irq_bit(BIT_RTC_INTERRUPTS_REG_IT_TIMER_M);
+	else
+		ret = mask_rtc_irq_bit(BIT_RTC_INTERRUPTS_REG_IT_TIMER_M);
+
+	return ret;
+}
+
+#if 1 /* Debugging periodic interrupts */
+/*
+ * We will just handle setting the frequency and make use the framework for
+ * reading the periodic interupts.
+ *
+ * @freq: Current periodic IRQ freq:
+ * bit 0: every second
+ * bit 1: every minute
+ * bit 2: every hour
+ * bit 3: every day
+ */
+
+static int tps65910_rtc_irq_set_freq(struct device *dev, int freq)
+{
+	struct rtc_device *rtc = dev_get_drvdata(dev);
+
+	if (freq < 0 || freq > 3)
+		return -EINVAL;
+
+	rtc->irq_freq = freq;
+	/* set rtc irq freq to user defined value */
+	set_rtc_irq_bit(freq);
+
+	return 0;
+}
+#endif
+
+/*
+ * Gets current TPS65910 RTC time and date parameters.
+ *
+ * The RTC's time/alarm representation is not what gmtime(3) requires
+ * Linux to use:
+ *
+ *  - Months are 1..12 vs Linux 0-11
+ *  - Years are 0..99 vs Linux 1900..N (we assume 21st century)
+ */
+static int tps65910_rtc_read_time(struct device *dev, struct rtc_time *tm)
+{
+	unsigned char rtc_data[ALL_TIME_REGS + 1];
+	int ret;
+	u8 save_control;
+
+	tps65910_rtc_read_u8(&save_control, TPS65910_REG_RTC_CTRL);
+	ret = tps65910_rtc_read_u8(&save_control, TPS65910_REG_RTC_CTRL);
+	if (ret < 0)
+		return ret;
+
+	save_control &= ~BIT_RTC_CTRL_REG_RTC_V_OPT_M;
+
+	ret = tps65910_rtc_write_u8(save_control, TPS65910_REG_RTC_CTRL);
+	if (ret < 0)
+		return ret;
+
+	ret = tps65910_rtc_read_u8(&rtc_data[0], TPS65910_REG_SECONDS);
+	if (ret < 0) {
+		dev_err(dev, "rtc_read_time error %d\n", ret);
+		return ret;
+	}
+	ret = tps65910_rtc_read_u8(&rtc_data[1], TPS65910_REG_MINUTES);
+	if (ret < 0) {
+		dev_err(dev, "rtc_read_time error %d\n", ret);
+		return ret;
+	}
+	ret = tps65910_rtc_read_u8(&rtc_data[2], TPS65910_REG_HOURS);
+	if (ret < 0) {
+		dev_err(dev, "rtc_read_time error %d\n", ret);
+		return ret;
+	}
+	ret = tps65910_rtc_read_u8(&rtc_data[3], TPS65910_REG_DAYS);
+	if (ret < 0) {
+		dev_err(dev, "rtc_read_time error %d\n", ret);
+		return ret;
+	}
+	ret = tps65910_rtc_read_u8(&rtc_data[4], TPS65910_REG_MONTHS);
+	if (ret < 0) {
+		dev_err(dev, "rtc_read_time error %d\n", ret);
+		return ret;
+	}
+	ret = tps65910_rtc_read_u8(&rtc_data[5], TPS65910_REG_YEARS);
+	if (ret < 0) {
+		dev_err(dev, "rtc_read_time error %d\n", ret);
+		return ret;
+	}
+
+	tm->tm_sec = bcd2bin(rtc_data[0]);
+	tm->tm_min = bcd2bin(rtc_data[1]);
+	tm->tm_hour = bcd2bin(rtc_data[2]);
+	tm->tm_mday = bcd2bin(rtc_data[3]);
+	tm->tm_mon = bcd2bin(rtc_data[4]) - 1;
+	tm->tm_year = bcd2bin(rtc_data[5]) + 100;
+
+	return ret;
+}
+
+static int tps65910_rtc_set_time(struct device *dev, struct rtc_time *tm)
+{
+	unsigned char save_control;
+	unsigned char rtc_data[ALL_TIME_REGS + 1];
+	int ret;
+
+	rtc_data[1] = bin2bcd(tm->tm_sec);
+	rtc_data[2] = bin2bcd(tm->tm_min);
+	rtc_data[3] = bin2bcd(tm->tm_hour);
+	rtc_data[4] = bin2bcd(tm->tm_mday);
+	rtc_data[5] = bin2bcd(tm->tm_mon + 1);
+	rtc_data[6] = bin2bcd(tm->tm_year - 100);
+
+	/*Dummy read*/
+	ret = tps65910_rtc_read_u8(&save_control, TPS65910_REG_RTC_CTRL);
+
+	/* Stop RTC while updating the TC registers */
+	ret = tps65910_rtc_read_u8(&save_control, TPS65910_REG_RTC_CTRL);
+	if (ret < 0)
+		goto out;
+
+	save_control &= ~BIT_RTC_CTRL_REG_STOP_RTC_M;
+
+	tps65910_rtc_write_u8(save_control, TPS65910_REG_RTC_CTRL);
+
+	/* update all the time registers in one shot */
+	ret = tps65910_rtc_write_u8(rtc_data[1], TPS65910_REG_SECONDS);
+	if (ret < 0) {
+		dev_err(dev, "rtc_write_time error %d\n", ret);
+		return ret;
+	}
+	ret = tps65910_rtc_write_u8(rtc_data[2], TPS65910_REG_MINUTES);
+	if (ret < 0) {
+		dev_err(dev, "rtc_write_time error %d\n", ret);
+		return ret;
+	}
+	ret = tps65910_rtc_write_u8(rtc_data[3], TPS65910_REG_HOURS);
+	if (ret < 0) {
+		dev_err(dev, "rtc_write_time error %d\n", ret);
+		return ret;
+	}
+	ret = tps65910_rtc_write_u8(rtc_data[4], TPS65910_REG_DAYS);
+	if (ret < 0) {
+		dev_err(dev, "rtc_write_time error %d\n", ret);
+		return ret;
+	}
+	ret = tps65910_rtc_write_u8(rtc_data[5], TPS65910_REG_MONTHS);
+	if (ret < 0) {
+		dev_err(dev, "rtc_write_time error %d\n", ret);
+		return ret;
+	}
+	ret = tps65910_rtc_write_u8(rtc_data[6], TPS65910_REG_YEARS);
+	if (ret < 0) {
+		dev_err(dev, "rtc_write_time error %d\n", ret);
+		return ret;
+	}
+
+	/*Dummy read*/
+	ret = tps65910_rtc_read_u8(&save_control, TPS65910_REG_RTC_CTRL);
+
+	ret = tps65910_rtc_read_u8(&save_control, TPS65910_REG_RTC_CTRL);
+	if (ret < 0)
+		goto out;
+	/* Start back RTC */
+	save_control |= BIT_RTC_CTRL_REG_STOP_RTC_M;
+	ret = tps65910_rtc_write_u8(save_control, TPS65910_REG_RTC_CTRL);
+
+out:
+	return ret;
+}
+
+/*
+ * Gets current TPS65910 RTC alarm time.
+ */
+static int tps65910_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)
+{
+	unsigned char rtc_data[ALL_TIME_REGS + 1];
+	int ret;
+
+	ret = tps65910_rtc_read_u8(&rtc_data[0], TPS65910_REG_ALARM_SECONDS);
+	if (ret < 0) {
+		dev_err(dev, "rtc_read_time error %d\n", ret);
+		return ret;
+	}
+	ret = tps65910_rtc_read_u8(&rtc_data[1], TPS65910_REG_ALARM_MINUTES);
+	if (ret < 0) {
+		dev_err(dev, "rtc_read_time error %d\n", ret);
+		return ret;
+	}
+	ret = tps65910_rtc_read_u8(&rtc_data[2], TPS65910_REG_ALARM_HOURS);
+	if (ret < 0) {
+		dev_err(dev, "rtc_read_time error %d\n", ret);
+		return ret;
+	}
+	ret = tps65910_rtc_read_u8(&rtc_data[3], TPS65910_REG_ALARM_DAYS);
+	if (ret < 0) {
+		dev_err(dev, "rtc_read_time error %d\n", ret);
+		return ret;
+	}
+	ret = tps65910_rtc_read_u8(&rtc_data[4], TPS65910_REG_ALARM_MONTHS);
+	if (ret < 0) {
+		dev_err(dev, "rtc_read_time error %d\n", ret);
+		return ret;
+	}
+	ret = tps65910_rtc_read_u8(&rtc_data[5], TPS65910_REG_ALARM_YEARS);
+	if (ret < 0) {
+		dev_err(dev, "rtc_read_time error %d\n", ret);
+		return ret;
+	}
+
+	/* some of these fields may be wildcard/"match all" */
+	alm->time.tm_sec = bcd2bin(rtc_data[0]);
+	alm->time.tm_min = bcd2bin(rtc_data[1]);
+	alm->time.tm_hour = bcd2bin(rtc_data[2]);
+	alm->time.tm_mday = bcd2bin(rtc_data[3]);
+	alm->time.tm_mon = bcd2bin(rtc_data[4]) - 1;
+	alm->time.tm_year = bcd2bin(rtc_data[5]) + 100;
+
+	/* report cached alarm enable state */
+	if (rtc_irq_bits & BIT_RTC_INTERRUPTS_REG_IT_ALARM_M)
+		alm->enabled = 1;
+
+	return ret;
+}
+
+static int tps65910_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)
+{
+	unsigned char alarm_data[ALL_TIME_REGS + 1];
+	int ret;
+
+	ret = tps65910_rtc_alarm_irq_enable(dev, 0);
+	if (ret)
+		goto out;
+
+	alarm_data[1] = bin2bcd(alm->time.tm_sec);
+	alarm_data[2] = bin2bcd(alm->time.tm_min);
+	alarm_data[3] = bin2bcd(alm->time.tm_hour);
+	alarm_data[4] = bin2bcd(alm->time.tm_mday);
+	alarm_data[5] = bin2bcd(alm->time.tm_mon + 1);
+	alarm_data[6] = bin2bcd(alm->time.tm_year - 100);
+
+	/* update all the alarm registers in one shot */
+	ret = tps65910_rtc_write_u8(alarm_data[1], TPS65910_REG_ALARM_SECONDS);
+	if (ret < 0) {
+		dev_err(dev, "rtc_write_time error %d\n", ret);
+		return ret;
+	}
+	ret = tps65910_rtc_write_u8(alarm_data[2], TPS65910_REG_ALARM_MINUTES);
+	if (ret < 0) {
+		dev_err(dev, "rtc_write_time error %d\n", ret);
+		return ret;
+	}
+	ret = tps65910_rtc_write_u8(alarm_data[3], TPS65910_REG_ALARM_HOURS);
+	if (ret < 0) {
+		dev_err(dev, "rtc_write_time error %d\n", ret);
+		return ret;
+	}
+	ret = tps65910_rtc_write_u8(alarm_data[4], TPS65910_REG_ALARM_DAYS);
+	if (ret < 0) {
+		dev_err(dev, "rtc_write_time error %d\n", ret);
+		return ret;
+	}
+	ret = tps65910_rtc_write_u8(alarm_data[5], TPS65910_REG_ALARM_MONTHS);
+	if (ret < 0) {
+		dev_err(dev, "rtc_write_time error %d\n", ret);
+		return ret;
+	}
+	ret = tps65910_rtc_write_u8(alarm_data[6], TPS65910_REG_ALARM_YEARS);
+	if (ret < 0) {
+		dev_err(dev, "rtc_write_time error %d\n", ret);
+		return ret;
+	}
+
+	if (alm->enabled)
+		ret = tps65910_rtc_alarm_irq_enable(dev, 1);
+out:
+	return ret;
+}
+
+
+struct work_struct rtc_wq;
+unsigned long rtc_events;
+struct rtc_device *global_rtc;
+
+void  rtc_work(void  *data)
+{
+
+	int res;
+	u8 rd_reg;
+	unsigned long events = 0;
+
+	res = tps65910_rtc_read_u8(&rd_reg, TPS65910_REG_INT_STS);
+
+	if (res < 0)
+		goto out;
+	/*
+	 * Figure out source of interrupt: ALARM or TIMER in RTC_STATUS_REG.
+	 * only one (ALARM or RTC) interrupt source may be enabled
+	 * at time, we also could check our results
+	 * by reading RTS_INTERRUPTS_REGISTER[IT_TIMER,IT_ALARM]
+	 */
+	if (rd_reg & TPS65910_RTC_ALARM_IT) {
+		res = tps65910_rtc_write_u8(rd_reg | TPS65910_RTC_ALARM_IT,
+				TPS65910_REG_INT_STS);
+		if (res < 0)
+			goto out;
+
+		/*Dummy read -- mandatory for status register*/
+		res = tps65910_rtc_read_u8(&rd_reg, TPS65910_REG_RTC_STATUS);
+		mdelay(100);
+		res = tps65910_rtc_read_u8(&rd_reg, TPS65910_REG_RTC_STATUS);
+		res = tps65910_rtc_write_u8(rd_reg, TPS65910_REG_RTC_STATUS);
+
+		rtc_events |= RTC_IRQF | RTC_AF;
+	} else if (rd_reg & TPS65910_RTC_PERIOD_IT) {
+		res = tps65910_rtc_write_u8(rd_reg | TPS65910_RTC_PERIOD_IT,
+				TPS65910_REG_INT_STS);
+		if (res < 0)
+			goto out;
+
+		/*Dummy read -- mandatory for status register*/
+		res = tps65910_rtc_read_u8(&rd_reg, TPS65910_REG_RTC_STATUS);
+		mdelay(100);
+		res = tps65910_rtc_read_u8(&rd_reg, TPS65910_REG_RTC_STATUS);
+		rd_reg &= 0xC3;
+		res = tps65910_rtc_write_u8(rd_reg, TPS65910_REG_RTC_STATUS);
+		rtc_events |= RTC_IRQF | RTC_UF;
+	}
+out:
+	/* Notify RTC core on event */
+	events = rtc_events;
+	rtc_update_irq(global_rtc, 1, events);
+}
+
+static struct rtc_class_ops tps65910_rtc_ops = {
+	.read_time	= tps65910_rtc_read_time,
+	.set_time	= tps65910_rtc_set_time,
+	.read_alarm	= tps65910_rtc_read_alarm,
+	.set_alarm	= tps65910_rtc_set_alarm,
+	.alarm_irq_enable = tps65910_rtc_alarm_irq_enable,
+	.update_irq_enable = tps65910_rtc_update_irq_enable,
+	.irq_set_freq	= tps65910_rtc_irq_set_freq,
+};
+
+static int __devinit tps65910_rtc_probe(struct platform_device *pdev)
+{
+	struct rtc_device *rtc;
+	int ret = 0;
+	u8 rd_reg;
+
+	rtc = rtc_device_register(pdev->name,
+			&pdev->dev, &tps65910_rtc_ops, THIS_MODULE);
+
+	if (IS_ERR(rtc)) {
+		ret = PTR_ERR(rtc);
+		dev_err(&pdev->dev, "can't register TPS65910 RTC device,\
+					 err %ld\n", PTR_ERR(rtc));
+		goto out0;
+
+	}
+	printk(KERN_INFO "TPS65910 RTC device successfully registered\n");
+
+	platform_set_drvdata(pdev, rtc);
+
+	/* Take rtc out of reset */
+	tps65910_rtc_read_u8(&rd_reg, TPS65910_REG_DEVCTRL);
+	rd_reg &= ~BIT_RTC_PWDN;
+	ret = tps65910_rtc_write_u8(rd_reg, TPS65910_REG_DEVCTRL);
+
+	/* Dummy read to ensure that the register gets updated.
+	 * Please refer tps65910 TRM table:25 for details
+	 */
+	tps65910_rtc_read_u8(&rd_reg, TPS65910_REG_RTC_STATUS);
+
+	ret = tps65910_rtc_read_u8(&rd_reg, TPS65910_REG_RTC_STATUS);
+	if (ret < 0) {
+		printk(KERN_ERR "TPS65910 RTC STATUS REG READ FAILED\n");
+		goto out1;
+	}
+
+	if (rd_reg & BIT_RTC_STATUS_REG_POWER_UP_M)
+		dev_warn(&pdev->dev, "Power up reset detected.\n");
+
+	if (rd_reg & BIT_RTC_STATUS_REG_ALARM_M)
+		dev_warn(&pdev->dev, "Pending Alarm interrupt detected.\n");
+
+	/* Clear RTC Power up reset and pending alarm interrupts */
+	ret = tps65910_rtc_write_u8(rd_reg, TPS65910_REG_RTC_STATUS);
+	if (ret < 0)
+		goto out1;
+	ret = tps65910_rtc_read_u8(&rd_reg, TPS65910_REG_INT_STS);
+	if (ret < 0) {
+		printk(KERN_ERR "TPS65910 RTC STATUS REG READ FAILED\n");
+		goto out1;
+	}
+
+	if (rd_reg & 0x40) {
+		printk(KERN_INFO "pending alarm interrupt!!! clearing!!!");
+		tps65910_rtc_write_u8(rd_reg, TPS65910_REG_INT_STS);
+	}
+
+	global_rtc = rtc;
+
+	/* Link RTC IRQ handler to TPS65910 Core */
+	tps65910_add_irq_work(TPS65910_RTC_ALARM_IRQ, rtc_work);
+	tps65910_add_irq_work(TPS65910_RTC_PERIOD_IRQ, rtc_work);
+
+	/* Check RTC module status, Enable if it is off */
+	ret = tps65910_rtc_read_u8(&rd_reg, TPS65910_REG_RTC_CTRL);
+	if (ret < 0)
+		goto out1;
+
+	if (!(rd_reg & BIT_RTC_CTRL_REG_STOP_RTC_M)) {
+		dev_info(&pdev->dev, "Enabling TPS65910-RTC.\n");
+		rd_reg |= BIT_RTC_CTRL_REG_STOP_RTC_M;
+		ret = tps65910_rtc_write_u8(rd_reg, TPS65910_REG_RTC_CTRL);
+		if (ret < 0)
+			goto out1;
+	}
+
+	/* init cached IRQ enable bits */
+	ret = tps65910_rtc_read_u8(&rtc_irq_bits, TPS65910_REG_RTC_INTERRUPTS);
+	if (ret < 0)
+		goto out1;
+
+	tps65910_rtc_write_u8(0x3F, TPS65910_REG_INT_MSK);
+	return ret;
+
+out1:
+	rtc_device_unregister(rtc);
+out0:
+	return ret;
+}
+
+/*
+ * Disable all TPS65910 RTC module interrupts.
+ * Sets status flag to free.
+ */
+static int __devexit tps65910_rtc_remove(struct platform_device *pdev)
+{
+	/* leave rtc running, but disable irqs */
+	struct rtc_device *rtc = platform_get_drvdata(pdev);
+	int irq = platform_get_irq(pdev, 0);
+
+	mask_rtc_irq_bit(BIT_RTC_INTERRUPTS_REG_IT_ALARM_M);
+	mask_rtc_irq_bit(BIT_RTC_INTERRUPTS_REG_IT_TIMER_M);
+
+
+	free_irq(irq, rtc);
+
+	rtc_device_unregister(rtc);
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+static void tps65910_rtc_shutdown(struct platform_device *pdev)
+{
+	/* mask timer interrupts, but leave alarm interrupts on to enable
+	 * power-on when alarm is triggered
+	 */
+	mask_rtc_irq_bit(BIT_RTC_INTERRUPTS_REG_IT_TIMER_M);
+}
+
+#ifdef CONFIG_PM
+
+static unsigned char irqstat;
+
+	static
+int tps65910_rtc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	irqstat = rtc_irq_bits;
+	mask_rtc_irq_bit(BIT_RTC_INTERRUPTS_REG_IT_TIMER_M);
+	return 0;
+}
+
+static int tps65910_rtc_resume(struct platform_device *pdev)
+{
+	set_rtc_irq_bit(irqstat);
+	return 0;
+}
+
+#else
+#define tps65910_rtc_suspend NULL
+#define tps65910_rtc_resume  NULL
+#endif
+
+
+static struct platform_driver tps65910rtc_driver = {
+	.probe		= tps65910_rtc_probe,
+	.remove		= __devexit_p(tps65910_rtc_remove),
+	.shutdown	= tps65910_rtc_shutdown,
+	.suspend	= tps65910_rtc_suspend,
+	.resume		= tps65910_rtc_resume,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "tps65910_rtc",
+	},
+};
+static int __init tps65910_rtc_init(void)
+{
+	return platform_driver_register(&tps65910rtc_driver);
+}
+module_init(tps65910_rtc_init);
+
+static void __exit tps65910_rtc_exit(void)
+{
+	platform_driver_unregister(&tps65910rtc_driver);
+}
+module_exit(tps65910_rtc_exit);
+
+MODULE_ALIAS("platform:tps65910_rtc");
+MODULE_AUTHOR("Umesh K  <umeshk@mistralsolutions.com");
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index c80105b..1d9cf0c 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -468,7 +468,8 @@ static int check_reset_complete (
 			index + 1);

 		// what happens if HCS_N_CC(params) == 0 ?
-#if !defined(CONFIG_MACH_OMAP3EVM) && !defined(CONFIG_MACH_OMAP3517EVM)
+#if !defined(CONFIG_MACH_OMAP3EVM) && !defined(CONFIG_MACH_OMAP3517EVM) && \
+    !defined(CONFIG_MACH_CRANEBOARD)
 		port_status |= PORT_OWNER;
 #endif
 		port_status &= ~PORT_RWC_BITS;
@@ -927,7 +928,8 @@ static int ehci_hub_control (
 				ehci_dbg (ehci,
 					"port %d low speed --> companion\n",
 					wIndex + 1);
-#if !defined(CONFIG_MACH_OMAP3EVM) && !defined(CONFIG_MACH_OMAP3517EVM)
+#if !defined(CONFIG_MACH_OMAP3EVM) && !defined(CONFIG_MACH_OMAP3517EVM) && \
+    !defined(CONFIG_MACH_CRANEBOARD)
 				temp |= PORT_OWNER;
 #endif
 			} else {
@@ -978,7 +980,8 @@ error_exit:

 static void ehci_relinquish_port(struct usb_hcd *hcd, int portnum)
 {
-#if !defined(CONFIG_MACH_OMAP3EVM) && !defined(CONFIG_MACH_OMAP3517EVM)
+#if !defined(CONFIG_MACH_OMAP3EVM) && !defined(CONFIG_MACH_OMAP3517EVM) && \
+    !defined(CONFIG_MACH_CRANEBOARD)
 	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);

 	if (ehci_is_TDI(ehci))
diff --git a/drivers/usb/musb/Kconfig b/drivers/usb/musb/Kconfig
index dd1edfd..5ac688d 100644
--- a/drivers/usb/musb/Kconfig
+++ b/drivers/usb/musb/Kconfig
@@ -10,7 +10,7 @@ comment "Enable Host or Gadget support to see Inventra options"
 config USB_MUSB_HDRC
 	depends on (USB || USB_GADGET)
 	depends on (ARM || (BF54x && !BF544) || (BF52x && !BF522 && !BF523))
-	select NOP_USB_XCEIV if (ARCH_DAVINCI || MACH_OMAP3EVM || BLACKFIN || MACH_OMAP3517EVM)
+	select NOP_USB_XCEIV if (ARCH_DAVINCI || MACH_OMAP3EVM || BLACKFIN || MACH_OMAP3517EVM || MACH_CRANEBOARD)
 	select TWL4030_USB if MACH_OMAP_3430SDP
 	select USB_OTG_UTILS
 	tristate 'Inventra Highspeed Dual Role Controller (TI, ADI, ...)'
@@ -152,7 +152,7 @@ config MUSB_PIO_ONLY

 config USB_INVENTRA_DMA
 	bool
-	depends on USB_MUSB_HDRC && !MUSB_PIO_ONLY && !MACH_OMAP3517EVM
+	depends on USB_MUSB_HDRC && !MUSB_PIO_ONLY && !MACH_OMAP3517EVM && !MACH_CRANEBOARD
 	default ARCH_OMAP2430 || ARCH_OMAP34XX || BLACKFIN
 	help
 	  Enable DMA transfers using Mentor's engine.
@@ -182,7 +182,7 @@ config USB_TI_CPPI_DMA
 config USB_TI_CPPI41_DMA
 	bool
 	depends on USB_MUSB_HDRC && !MUSB_PIO_ONLY
-	default ARCH_DAVINCI_DA830 || MACH_OMAP3517EVM
+	default ARCH_DAVINCI_DA830 || MACH_OMAP3517EVM || MACH_CRANEBOARD
 	select CPPI41
 	help
 	 Enable DMA transfers when TI CPPI 4.1 DMA is available.
diff --git a/drivers/usb/musb/Makefile b/drivers/usb/musb/Makefile
index 01de383..daf3415 100644
--- a/drivers/usb/musb/Makefile
+++ b/drivers/usb/musb/Makefile
@@ -19,7 +19,8 @@ ifeq ($(CONFIG_ARCH_OMAP2430),y)
 endif

 ifeq ($(CONFIG_ARCH_OMAP3430),y)
-   ifeq ($(CONFIG_MACH_OMAP3517EVM),y)
+
+   ifeq ($(CONFIG_MACH_CRANEBOARD),y)
 	musb_hdrc-objs  += am3517.o
    else
 	musb_hdrc-objs	+= omap2430.o
diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c
index 98874c5..71ec7e8 100644
--- a/drivers/usb/musb/musb_core.c
+++ b/drivers/usb/musb/musb_core.c
@@ -1019,7 +1019,7 @@ static void musb_shutdown(struct platform_device *pdev)
  */
 #if defined(CONFIG_USB_TUSB6010) || \
 	defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP34XX) || \
-	defined(CONFIG_MACH_OMAP3517EVM)
+	defined(CONFIG_MACH_OMAP3517EVM) ||  defined(CONFIG_MACH_CRANEBOARD)
 static ushort __initdata fifo_mode = 4;
 #else
 static ushort __initdata fifo_mode = 2;
diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 0b19d0b..d7850c7 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -380,7 +380,7 @@ struct musb {
 	void __iomem		*sync_va;
 #endif

-#ifdef CONFIG_MACH_OMAP3517EVM
+#if defined(CONFIG_MACH_OMAP3517EVM) || defined(CONFIG_MACH_CRANEBOARD)
 /* Backup registers required for the workaround of AM3517 bytewise
  * read issue. FADDR, POWER, INTRTXE, INTRRXE and INTRUSBE register
  * read would actually clear the interrupt registers and would cause
diff --git a/drivers/usb/musb/musb_gadget.c b/drivers/usb/musb/musb_gadget.c
index c0e2efc..bb93de7 100644
--- a/drivers/usb/musb/musb_gadget.c
+++ b/drivers/usb/musb/musb_gadget.c
@@ -2024,7 +2024,7 @@ __acquires(musb->lock)


 	/* what speed did we negotiate? */
-#ifdef CONFIG_MACH_OMAP3517EVM
+#if defined(CONFIG_MACH_OMAP3517EVM) || defined(CONFIG_MACH_CRANEBOARD)
 	musb->read_mask &= ~AM3517_READ_ISSUE_POWER;
 #endif
 	power = musb_readb(mbase, MUSB_POWER);
diff --git a/drivers/usb/musb/musb_gadget_ep0.c b/drivers/usb/musb/musb_gadget_ep0.c
index 7a9dc1e..bcc754d 100644
--- a/drivers/usb/musb/musb_gadget_ep0.c
+++ b/drivers/usb/musb/musb_gadget_ep0.c
@@ -770,7 +770,7 @@ setup:
 				printk(KERN_NOTICE "%s: peripheral reset "
 						"irq lost!\n",
 						musb_driver_name);
-#ifdef CONFIG_MACH_OMAP3517EVM
+#if defined(CONFIG_MACH_OMAP3517EVM) || defined(CONFIG_MACH_CRANEBOARD)
 				musb->read_mask &= ~AM3517_READ_ISSUE_POWER;
 #endif
 				power = musb_readb(mbase, MUSB_POWER);
diff --git a/drivers/usb/musb/musb_io.h b/drivers/usb/musb/musb_io.h
index 0969d88..e578061 100644
--- a/drivers/usb/musb/musb_io.h
+++ b/drivers/usb/musb/musb_io.h
@@ -56,7 +56,8 @@ static inline void writesb(const void __iomem *addr, const void *buf, int len)

 #endif

-#if !defined(CONFIG_BLACKFIN) && !defined(CONFIG_MACH_OMAP3517EVM)
+#if !defined(CONFIG_BLACKFIN) && !defined(CONFIG_MACH_OMAP3517EVM) && \
+    !defined(CONFIG_MACH_CRANEBOARD)

 /* NOTE:  these offsets are all in bytes */
 
@@ -136,7 +137,7 @@ static inline void musb_writew(void __iomem *addr, unsigned offset, u16 data)
 static inline void musb_writel(void __iomem *addr, unsigned offset, u32 data)
 	{ bfin_write16(addr + offset, (u16) data); }

-#elif defined(CONFIG_MACH_OMAP3517EVM)
+#elif (defined(CONFIG_MACH_OMAP3517EVM) || defined(CONFIG_MACH_CRANEBOARD))

 /* AM3517 has a limitation on read operation. Only 32 bit read is
  * allowed and thus 8bit and 16bit read has to be handled differently
diff --git a/drivers/usb/musb/musb_virthub.c b/drivers/usb/musb/musb_virthub.c
index 0200a62..c1570b6 100644
--- a/drivers/usb/musb/musb_virthub.c
+++ b/drivers/usb/musb/musb_virthub.c
@@ -68,12 +68,12 @@ static void musb_port_suspend(struct musb *musb, bool do_suspend)
 		musb_writeb(mbase, MUSB_POWER, power);

 		/* Needed for OPT A tests */
-#ifdef CONFIG_MACH_OMAP3517EVM
+#if defined(CONFIG_MACH_OMAP3517EVM) || defined(CONFIG_MACH_CRANEBOARD)
 		musb->read_mask &= ~AM3517_READ_ISSUE_POWER;
 #endif
 		power = musb_readb(mbase, MUSB_POWER);
 		while (power & MUSB_POWER_SUSPENDM) {
-#ifdef CONFIG_MACH_OMAP3517EVM
+#if defined(CONFIG_MACH_OMAP3517EVM) || defined(CONFIG_MACH_CRANEBOARD)
 			musb->read_mask &= ~AM3517_READ_ISSUE_POWER;
 #endif
 			power = musb_readb(mbase, MUSB_POWER);
@@ -135,7 +135,7 @@ static void musb_port_reset(struct musb *musb, bool do_reset)
 	/* NOTE:  caller guarantees it will turn off the reset when
 	 * the appropriate amount of time has passed
 	 */
-#ifdef CONFIG_MACH_OMAP3517EVM
+#if defined(CONFIG_MACH_OMAP3517EVM) || defined(CONFIG_MACH_CRANEBOARD)
 	musb->read_mask &= ~AM3517_READ_ISSUE_POWER;
 #endif
 	power = musb_readb(mbase, MUSB_POWER);
@@ -171,7 +171,7 @@ static void musb_port_reset(struct musb *musb, bool do_reset)

 		musb->ignore_disconnect = false;

-#ifdef CONFIG_MACH_OMAP3517EVM
+#if defined(CONFIG_MACH_OMAP3517EVM) || defined(CONFIG_MACH_CRANEBOARD)
 		musb->read_mask &= ~AM3517_READ_ISSUE_POWER;
 #endif
 		power = musb_readb(mbase, MUSB_POWER);
diff --git a/drivers/video/omap2/displays/panel-generic.c b/drivers/video/omap2/displays/panel-generic.c
index eb48d1a..ad9ecc2 100644
--- a/drivers/video/omap2/displays/panel-generic.c
+++ b/drivers/video/omap2/displays/panel-generic.c
@@ -26,7 +26,11 @@ static struct omap_video_timings generic_panel_timings = {
 	/* 640 x 480 @ 60 Hz  Reduced blanking VESA CVT 0.31M3-R */
 	.x_res		= 640,
 	.y_res		= 480,
+#ifdef CONFIG_MACH_CRANEBOARD
+	.pixel_clock	= 24000,
+#else
 	.pixel_clock	= 23500,
+#endif
 	.hfp		= 48,
 	.hsw		= 32,
 	.hbp		= 80,
@@ -37,7 +41,12 @@ static struct omap_video_timings generic_panel_timings = {

 static int generic_panel_probe(struct omap_dss_device *dssdev)
 {
+#ifdef CONFIG_MACH_CRANEBOARD
+	dssdev->panel.config = (OMAP_DSS_LCD_TFT | OMAP_DSS_LCD_IVS |
+				OMAP_DSS_LCD_IHS | OMAP_DSS_LCD_IPC);
+#else
 	dssdev->panel.config = OMAP_DSS_LCD_TFT;
+#endif
 	dssdev->panel.timings = generic_panel_timings;

 	return 0;
diff --git a/drivers/video/omap2/dss/venc.c b/drivers/video/omap2/dss/venc.c
index 1127e85..8be116f 100644
--- a/drivers/video/omap2/dss/venc.c
+++ b/drivers/video/omap2/dss/venc.c
@@ -292,7 +292,9 @@ static struct {
 	void __iomem *base;
 	struct mutex venc_lock;
 	u32 wss_data;
+#ifndef CONFIG_MACH_CRANEBOARD
 	struct regulator *vdda_dac_reg;
+#endif
 } venc;

 static inline void venc_write_reg(int idx, u32 val)
@@ -503,13 +505,14 @@ int venc_init(struct platform_device *pdev)
 		return -ENOMEM;
 	}

+#ifndef CONFIG_MACH_CRANEBOARD
 	venc.vdda_dac_reg = regulator_get(&pdev->dev, "vdda_dac");
 	if (IS_ERR(venc.vdda_dac_reg)) {
 		iounmap(venc.base);
 		DSSERR("can't get VDDA_DAC regulator\n");
 		return PTR_ERR(venc.vdda_dac_reg);
 	}
-
+#endif
 	venc_enable_clocks(1);

 	rev_id = (u8)(venc_read_reg(VENC_REV_ID) & 0xff);
@@ -523,9 +526,9 @@ int venc_init(struct platform_device *pdev)
 void venc_exit(void)
 {
 	omap_dss_unregister_driver(&venc_driver);
-
+#ifndef CONFIG_MACH_CRANEBOARD
 	regulator_put(venc.vdda_dac_reg);
-
+#endif
 	iounmap(venc.base);
 }

@@ -576,8 +579,9 @@ static int venc_power_on(struct omap_dss_device *dssdev)
 	dispc_set_digit_size(dssdev->panel.timings.x_res,
 			dssdev->panel.timings.y_res/2);

+#ifndef CONFIG_MACH_CRANEBOARD
 	regulator_enable(venc.vdda_dac_reg);
-
+#endif
 	if (dssdev->platform_enable)
 		dssdev->platform_enable(dssdev);

@@ -604,8 +608,9 @@ static void venc_power_off(struct omap_dss_device *dssdev)
 	if (dssdev->platform_disable)
 		dssdev->platform_disable(dssdev);

+#ifndef CONFIG_MACH_CRANEBOARD
 	regulator_disable(venc.vdda_dac_reg);
-
+#endif
 #ifdef CONFIG_OMAP2_DSS_USE_DSI_PLL
 	dsi_pll_uninit();
 	dss_clk_disable(DSS_CLK_FCK2);
diff --git a/include/linux/i2c/tps65910.h b/include/linux/i2c/tps65910.h
new file mode 100644
index 0000000..1362de4
--- /dev/null
+++ b/include/linux/i2c/tps65910.h
@@ -0,0 +1,278 @@
+/* linux/i2c/tps65910.h
+ *
+ *  TPS65910 Power Management Device Definitions.
+ *
+ * Based on include/linux/i2c/twl.h
+ *
+ * Copyright (C) 2010 Mistral Solutions Pvt Ltd <www.mistralsolutions.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __LINUX_I2C_TPS65910_H
+#define __LINUX_I2C_TPS65910_H
+
+#define TPS65910_NUM_SLAVES	2
+/* I2C Slave Address 7-bit */
+#define	TPS65910_I2C_ID0	0x2D /* general-purpose */
+#define	TPS65910_I2C_ID1	0x12 /* Smart Reflex */
+
+/* TPS65910 to host IRQ */
+#define TPS65910_HOST_IRQ 	INT_34XX_SYS_NIRQ
+
+/* TPS65910 MAX GPIOs */
+#define TPS65910_GPIO_MAX	1
+
+/*
+ * ----------------------------------------------------------------------------
+ * Registers, all 8 bits
+ * ----------------------------------------------------------------------------
+ */
+#define	TPS65910_REG_SECONDS		0x00
+#define TPS65910_REG_MINUTES		0x01
+#define TPS65910_REG_HOURS		0x02
+#define TPS65910_REG_DAYS		0x03
+#define TPS65910_REG_MONTHS		0x04
+#define TPS65910_REG_YEARS		0x05
+#define TPS65910_REG_WEEKS		0x06
+#define TPS65910_REG_ALARM_SECONDS	0x08
+#define TPS65910_REG_ALARM_MINUTES	0x09
+#define TPS65910_REG_ALARM_HOURS	0x0A
+#define TPS65910_REG_ALARM_DAYS		0x0B
+#define TPS65910_REG_ALARM_MONTHS	0x0C
+#define TPS65910_REG_ALARM_YEARS	0x0D
+
+#define TPS65910_REG_RTC_CTRL		0x10
+#define TPS65910_REG_RTC_STATUS		0x11
+#define TPS65910_REG_RTC_INTERRUPTS	0x12
+#define TPS65910_REG_RTC_COMP_LSB	0x13
+#define TPS65910_REG_RTC_COMP_MSB	0x14
+#define TPS65910_REG_RTC_RES_PROG	0x15
+#define TPS65910_REG_RTC_RESET_STATUS	0x16
+#define TPS65910_REG_BCK1		0x17
+#define TPS65910_REG_BCK2		0x18
+#define TPS65910_REG_BCK3		0x19
+#define TPS65910_REG_BCK4		0x1A
+#define TPS65910_REG_BCK5		0x1B
+#define TPS65910_REG_PUADEN		0x1C
+#define TPS65910_REG_REF		0x1D
+#define TPS65910_REG_VRTC		0x1E
+
+#define TPS65910_REG_VIO		0x20
+#define TPS65910_REG_VDD1		0x21
+#define TPS65910_REG_VDD1_OP		0x22
+#define TPS65910_REG_VDD1_SR		0x23
+#define TPS65910_REG_VDD2		0x24
+#define TPS65910_REG_VDD2_OP		0x25
+#define TPS65910_REG_VDD2_SR		0x26
+#define TPS65910_REG_VDD3		0x27
+
+#define TPS65910_REG_VDIG1		0x30
+#define TPS65910_REG_VDIG2		0x31
+#define TPS65910_REG_VAUX1		0x32
+#define TPS65910_REG_VAUX2		0x33
+#define TPS65910_REG_VAUX33		0x34
+#define TPS65910_REG_VMMC		0x35
+#define TPS65910_REG_VPLL		0x36
+#define TPS65910_REG_VDAC		0x37
+#define TPS65910_REG_THERM		0x38
+#define TPS65910_REG_BBCH		0x39
+
+#define TPS65910_REG_DCDCCTRL		0x3E
+#define TPS65910_REG_DEVCTRL		0x3F
+#define TPS65910_REG_DEVCTRL2		0x40
+#define TPS65910_REG_SLEEP_KEEP_LDO_ON	0x41
+#define TPS65910_REG_SLEEP_KEEP_RES_ON	0x42
+#define TPS65910_REG_SLEEP_SET_LDO_OFF	0x43
+#define TPS65910_REG_SLEEP_SET_RES_OFF	0x44
+#define TPS65910_REG_EN1_LDO_ASS	0x45
+#define TPS65910_REG_EN1_SMPS_ASS	0x46
+#define TPS65910_REG_EN2_LDO_ASS	0x47
+#define TPS65910_REG_EN2_SMPS_ASS	0x48
+#define TPS65910_REG_EN3_LDO_ASS	0x49
+#define TPS65910_REG_SPARE		0x4A
+
+#define TPS65910_REG_INT_STS		0x50
+#define TPS65910_REG_INT_MSK		0x51
+#define TPS65910_REG_INT_STS2		0x52
+#define TPS65910_REG_INT_MSK2		0x53
+#define TPS65910_REG_INT_STS3		0x54
+#define TPS65910_REG_INT_MSK3		0x55
+
+#define TPS65910_REG_GPIO0		0x60
+
+#define TPS65910_REG_JTAGVERNUM		0x80
+
+/* TPS65910 GPIO Specific flags */
+#define TPS65910_GPIO_INT_FALLING	0
+#define TPS65910_GPIO_INT_RISING	1
+
+#define TPS65910_DEBOUNCE_91_5_MS	0
+#define TPS65910_DEBOUNCE_150_MS	1
+
+#define TPS65910_GPIO_PUDIS		(1 << 3)
+#define TPS65910_GPIO_CFG_OUTPUT	(1 << 2)
+
+
+
+/* TPS65910 Interrupt events */
+
+/* RTC Driver */
+#define TPS65910_RTC_ALARM_IT		0x80
+#define TPS65910_RTC_PERIOD_IT		0x40
+
+/*Core Driver */
+#define TPS65910_HOT_DIE_IT		0x20
+#define TPS65910_PWRHOLD_IT		0x10
+#define TPS65910_PWRON_LP_IT		0x08
+#define TPS65910_PWRON_IT		0x04
+#define TPS65910_VMBHI_IT		0x02
+#define TPS65910_VMBGCH_IT		0x01
+
+/* GPIO driver */
+#define TPS65910_GPIO_F_IT		0x02
+#define TPS65910_GPIO_R_IT		0x01
+
+
+#define TPS65910_VRTC_OFFMASK		(1<<3)
+
+/* Back-up battery charger control */
+#define TPS65910_BBCHEN			0x01
+
+/* Back-up battery charger voltage */
+#define TPS65910_BBSEL_3P0		0x00
+#define TPS65910_BBSEL_2P52		0x02
+#define TPS65910_BBSEL_3P15		0x04
+#define TPS65910_BBSEL_VBAT		0x06
+
+/* DEVCTRL_REG flags */
+#define TPS65910_RTC_PWDNN		0x40
+#define TPS65910_CK32K_CTRL		0x20
+#define TPS65910_SR_CTL_I2C_SEL 	0x10
+#define TPS65910_DEV_OFF_RST		0x08
+#define TPS65910_DEV_ON			0x04
+#define TPS65910_DEV_SLP		0x02
+#define TPS65910_DEV_OFF		0x01
+
+/* DEVCTRL2_REG flags */
+#define TPS65910_DEV2_TSLOT_LENGTH	0x30
+#define TPS65910_DEV2_SLEEPSIG_POL	0x08
+#define TPS65910_DEV2_PWON_LP_OFF	0x04
+#define TPS65910_DEV2_PWON_LP_RST	0x02
+#define TPS65910_DEV2_IT_POL		0x01
+
+/* TPS65910 SMPS/LDO's */
+#define TPS65910_VIO			0
+#define TPS65910_VDD1			1
+#define TPS65910_VDD2			2
+#define TPS65910_VDD3			3
+/* LDOs */
+#define TPS65910_VDIG1			4
+#define TPS65910_VDIG2			5
+#define TPS65910_VAUX33			6
+#define TPS65910_VMMC			7
+#define TPS65910_VAUX1			8
+#define TPS65910_VAUX2			9
+#define TPS65910_VDAC			10
+#define TPS65910_VPLL			11
+/* Internal LDO */
+#define TPS65910_VRTC			12
+
+/* Number of step-down/up converters available */
+#define TPS65910_NUM_DCDC		4
+
+/* Number of LDO voltage regulators  available */
+#define TPS65910_NUM_LDO		9
+
+/* Number of total regulators available */
+#define TPS65910_NUM_REGULATOR  (TPS65910_NUM_DCDC + TPS65910_NUM_LDO)
+
+
+/* Regulator Supply state */
+#define SUPPLY_STATE_FLAG		0x03
+/* OFF States */
+#define TPS65910_REG_OFF_00		0x00
+#define TPS65910_REG_OFF_10		0x02
+/* OHP - on High Power */
+#define TPS65910_REG_OHP		0x01
+/* OLP - on Low Power */
+#define TPS65910_REG_OLP		0x03
+
+#define TPS65910_MAX_IRQS		10
+#define TPS65910_VMBDCH_IRQ     	0
+#define TPS65910_VMBHI_IRQ      	1
+#define TPS65910_PWRON_IRQ      	2
+#define TPS65910_PWRON_LP_IRQ   	3
+#define TPS65910_PWRHOLD_IRQ    	4
+#define TPS65910_HOTDIE_IRQ     	5
+#define TPS65910_RTC_ALARM_IRQ  	6
+#define TPS65910_RTC_PERIOD_IRQ 	7
+#define TPS65910_GPIO0_R_IRQ    	8
+#define TPS65910_GPIO0_F_IRQ    	9
+
+/* TPS65910 has 1 GPIO  */
+struct tps65910_gpio {
+	u8      debounce;
+	u8      pullup_pulldown;
+	u8 	gpio_config;  /* Input or output */
+	u8 	gpio_val;    /* Output value */
+	int (*gpio_setup)(struct tps65910_gpio *pdata);
+	int (*gpio_taredown)(struct tps65910_gpio *pdata);
+};
+
+struct tps65910_platform_data {
+
+	unsigned irq_num;  /* TPS65910 to Host IRQ Number */
+	struct tps65910_gpio	*gpio;
+
+	/* plaform specific data to be initialised in board file */
+	struct regulator_init_data *vio;
+	struct regulator_init_data *vdd1;
+	struct regulator_init_data *vdd2;
+	struct regulator_init_data *vdd3;
+	struct regulator_init_data *vdig1;
+	struct regulator_init_data *vdig2;
+	struct regulator_init_data *vaux33;
+	struct regulator_init_data *vmmc;
+	struct regulator_init_data *vaux1;
+	struct regulator_init_data *vaux2;
+	struct regulator_init_data *vdac;
+	struct regulator_init_data *vpll;
+
+	void  (*handlers[TPS65910_MAX_IRQS]) (void  *data);
+	/* Configure TP65910 to board specific usage*/
+	int (*board_tps65910_config)(struct tps65910_platform_data *pdata);
+};
+
+int tps65910_enable_bbch(u8 voltage);
+int tps65910_disable_bbch(void);
+
+int tps65910_remove_irq_work(int irq);
+int tps65910_add_irq_work(int irq, void (*handler)(void *data));
+
+int tps65910_i2c_write_u8(u8 slave_addr, u8 val, u8 reg);
+int tps65910_i2c_read_u8(u8 slave_addr, u8 *val, u8 reg);
+
+int tps65910_i2c_write(u8 slave_addr, u8 *value, u8 reg, unsigned num_bytes);
+int tps65910_i2c_read(u8 slave_addr, u8 *value, u8 reg, unsigned num_bytes);
+
+#endif /*  __LINUX_I2C_TPS65910_H */
+
--
1.7.0.4

